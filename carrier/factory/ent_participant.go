// Code generated by carrier, DO NOT EDIT.
package factory

import (
	"github.com/sergot/tibiago/ent"

	"github.com/google/uuid"

	"github.com/sergot/tibiago/ent/participant"

	"context"
)

type EntParticipantMutator struct {
	Bosslist *ent.Bosslist

	BosslistID uuid.UUID

	DiscordID string

	ID uuid.UUID

	Vocation participant.Vocation

	_creator *ent.ParticipantCreate
}

func (m *EntParticipantMutator) EntCreator() *ent.ParticipantCreate {
	return m._creator
}

type entParticipantMutation struct {
	bosslistType int
	bosslistFunc func(ctx context.Context, i *EntParticipantMutator, c int) error

	bosslistIDType int
	bosslistIDFunc func(ctx context.Context, i *EntParticipantMutator, c int) error

	discordIDType int
	discordIDFunc func(ctx context.Context, i *EntParticipantMutator, c int) error

	iDType int
	iDFunc func(ctx context.Context, i *EntParticipantMutator, c int) error

	vocationType int
	vocationFunc func(ctx context.Context, i *EntParticipantMutator, c int) error

	beforeCreateFunc func(ctx context.Context, i *EntParticipantMutator) error
	afterCreateFunc  func(ctx context.Context, i *ent.Participant) error
}
type EntParticipantMetaFactory struct {
	mutation entParticipantMutation
}
type entParticipantTrait struct {
	mutation entParticipantMutation
	updates  []func(m *entParticipantMutation)
}

func EntParticipantTrait() *entParticipantTrait {
	return &entParticipantTrait{}
}
func (*entParticipantMutation) beforeCreateMutateFunc(fn func(ctx context.Context, i *EntParticipantMutator) error) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.beforeCreateFunc = fn
	}
}
func (*entParticipantMutation) afterCreateMutateFunc(fn func(ctx context.Context, i *ent.Participant) error) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.afterCreateFunc = fn
	}
}

func (*entParticipantMutation) bosslistSequenceMutateFunc(fn func(ctx context.Context, i int) (*ent.Bosslist, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.bosslistType = TypeSequence
		m.bosslistFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetBosslist(value)

			i.Bosslist = value
			return nil
		}
	}
}
func (*entParticipantMutation) bosslistLazyMutateFunc(fn func(ctx context.Context, i *EntParticipantMutator) (*ent.Bosslist, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.bosslistType = TypeLazy
		m.bosslistFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetBosslist(value)

			i.Bosslist = value
			return nil
		}
	}
}
func (*entParticipantMutation) bosslistDefaultMutateFunc(v *ent.Bosslist) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.bosslistType = TypeDefault
		m.bosslistFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {

			i.EntCreator().SetBosslist(v)

			i.Bosslist = v
			return nil
		}
	}
}
func (*entParticipantMutation) bosslistFactoryMutateFunc(fn func(ctx context.Context) (*ent.Bosslist, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.bosslistType = TypeFactory
		m.bosslistFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetBosslist(value)

			i.Bosslist = value

			return nil
		}
	}
}

// SetBosslistSequence register a function which accept a sequence counter and set return value to Bosslist field
func (f *EntParticipantMetaFactory) SetBosslistSequence(fn func(ctx context.Context, i int) (*ent.Bosslist, error)) *EntParticipantMetaFactory {
	f.mutation.bosslistSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetBosslistLazy register a function which accept the build struct and set return value to Bosslist field
func (f *EntParticipantMetaFactory) SetBosslistLazy(fn func(ctx context.Context, i *EntParticipantMutator) (*ent.Bosslist, error)) *EntParticipantMetaFactory {
	f.mutation.bosslistLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetBosslistDefault assign a default value to Bosslist field
func (f *EntParticipantMetaFactory) SetBosslistDefault(v *ent.Bosslist) *EntParticipantMetaFactory {
	f.mutation.bosslistDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetBosslistFactory register a factory function and assign return value to Bosslist, you can also use related factory's Create/CreateV as input function here
func (f *EntParticipantMetaFactory) SetBosslistFactory(fn func(ctx context.Context) (*ent.Bosslist, error)) *EntParticipantMetaFactory {
	f.mutation.bosslistFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetBosslistSequence register a function which accept a sequence counter and set return value to Bosslist field
func (t *entParticipantTrait) SetBosslistSequence(fn func(ctx context.Context, i int) (*ent.Bosslist, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.bosslistSequenceMutateFunc(fn))
	return t
}

// SetBosslistLazy register a function which accept the build struct and set return value to Bosslist field
func (t *entParticipantTrait) SetBosslistLazy(fn func(ctx context.Context, i *EntParticipantMutator) (*ent.Bosslist, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.bosslistLazyMutateFunc(fn))
	return t
}

// SetBosslistDefault assign a default value to Bosslist field
func (t *entParticipantTrait) SetBosslistDefault(v *ent.Bosslist) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.bosslistDefaultMutateFunc(v))
	return t
}

// SetBosslistFactory register a factory function and assign return value to Bosslist, you can also use related factory's Create/CreateV as input function here
func (t *entParticipantTrait) SetBosslistFactory(fn func(ctx context.Context) (*ent.Bosslist, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.bosslistFactoryMutateFunc(fn))
	return t
}

func (*entParticipantMutation) bosslistIDSequenceMutateFunc(fn func(ctx context.Context, i int) (uuid.UUID, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.bosslistIDType = TypeSequence
		m.bosslistIDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetBosslistID(value)

			i.BosslistID = value
			return nil
		}
	}
}
func (*entParticipantMutation) bosslistIDLazyMutateFunc(fn func(ctx context.Context, i *EntParticipantMutator) (uuid.UUID, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.bosslistIDType = TypeLazy
		m.bosslistIDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetBosslistID(value)

			i.BosslistID = value
			return nil
		}
	}
}
func (*entParticipantMutation) bosslistIDDefaultMutateFunc(v uuid.UUID) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.bosslistIDType = TypeDefault
		m.bosslistIDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {

			i.EntCreator().SetBosslistID(v)

			i.BosslistID = v
			return nil
		}
	}
}
func (*entParticipantMutation) bosslistIDFactoryMutateFunc(fn func(ctx context.Context) (uuid.UUID, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.bosslistIDType = TypeFactory
		m.bosslistIDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetBosslistID(value)

			i.BosslistID = value

			return nil
		}
	}
}

// SetBosslistIDSequence register a function which accept a sequence counter and set return value to BosslistID field
func (f *EntParticipantMetaFactory) SetBosslistIDSequence(fn func(ctx context.Context, i int) (uuid.UUID, error)) *EntParticipantMetaFactory {
	f.mutation.bosslistIDSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetBosslistIDLazy register a function which accept the build struct and set return value to BosslistID field
func (f *EntParticipantMetaFactory) SetBosslistIDLazy(fn func(ctx context.Context, i *EntParticipantMutator) (uuid.UUID, error)) *EntParticipantMetaFactory {
	f.mutation.bosslistIDLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetBosslistIDDefault assign a default value to BosslistID field
func (f *EntParticipantMetaFactory) SetBosslistIDDefault(v uuid.UUID) *EntParticipantMetaFactory {
	f.mutation.bosslistIDDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetBosslistIDFactory register a factory function and assign return value to BosslistID, you can also use related factory's Create/CreateV as input function here
func (f *EntParticipantMetaFactory) SetBosslistIDFactory(fn func(ctx context.Context) (uuid.UUID, error)) *EntParticipantMetaFactory {
	f.mutation.bosslistIDFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetBosslistIDSequence register a function which accept a sequence counter and set return value to BosslistID field
func (t *entParticipantTrait) SetBosslistIDSequence(fn func(ctx context.Context, i int) (uuid.UUID, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.bosslistIDSequenceMutateFunc(fn))
	return t
}

// SetBosslistIDLazy register a function which accept the build struct and set return value to BosslistID field
func (t *entParticipantTrait) SetBosslistIDLazy(fn func(ctx context.Context, i *EntParticipantMutator) (uuid.UUID, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.bosslistIDLazyMutateFunc(fn))
	return t
}

// SetBosslistIDDefault assign a default value to BosslistID field
func (t *entParticipantTrait) SetBosslistIDDefault(v uuid.UUID) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.bosslistIDDefaultMutateFunc(v))
	return t
}

// SetBosslistIDFactory register a factory function and assign return value to BosslistID, you can also use related factory's Create/CreateV as input function here
func (t *entParticipantTrait) SetBosslistIDFactory(fn func(ctx context.Context) (uuid.UUID, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.bosslistIDFactoryMutateFunc(fn))
	return t
}

func (*entParticipantMutation) discordIDSequenceMutateFunc(fn func(ctx context.Context, i int) (string, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.discordIDType = TypeSequence
		m.discordIDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetDiscordID(value)

			i.DiscordID = value
			return nil
		}
	}
}
func (*entParticipantMutation) discordIDLazyMutateFunc(fn func(ctx context.Context, i *EntParticipantMutator) (string, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.discordIDType = TypeLazy
		m.discordIDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetDiscordID(value)

			i.DiscordID = value
			return nil
		}
	}
}
func (*entParticipantMutation) discordIDDefaultMutateFunc(v string) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.discordIDType = TypeDefault
		m.discordIDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {

			i.EntCreator().SetDiscordID(v)

			i.DiscordID = v
			return nil
		}
	}
}
func (*entParticipantMutation) discordIDFactoryMutateFunc(fn func(ctx context.Context) (string, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.discordIDType = TypeFactory
		m.discordIDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetDiscordID(value)

			i.DiscordID = value

			return nil
		}
	}
}

// SetDiscordIDSequence register a function which accept a sequence counter and set return value to DiscordID field
func (f *EntParticipantMetaFactory) SetDiscordIDSequence(fn func(ctx context.Context, i int) (string, error)) *EntParticipantMetaFactory {
	f.mutation.discordIDSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetDiscordIDLazy register a function which accept the build struct and set return value to DiscordID field
func (f *EntParticipantMetaFactory) SetDiscordIDLazy(fn func(ctx context.Context, i *EntParticipantMutator) (string, error)) *EntParticipantMetaFactory {
	f.mutation.discordIDLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetDiscordIDDefault assign a default value to DiscordID field
func (f *EntParticipantMetaFactory) SetDiscordIDDefault(v string) *EntParticipantMetaFactory {
	f.mutation.discordIDDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetDiscordIDFactory register a factory function and assign return value to DiscordID, you can also use related factory's Create/CreateV as input function here
func (f *EntParticipantMetaFactory) SetDiscordIDFactory(fn func(ctx context.Context) (string, error)) *EntParticipantMetaFactory {
	f.mutation.discordIDFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetDiscordIDSequence register a function which accept a sequence counter and set return value to DiscordID field
func (t *entParticipantTrait) SetDiscordIDSequence(fn func(ctx context.Context, i int) (string, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.discordIDSequenceMutateFunc(fn))
	return t
}

// SetDiscordIDLazy register a function which accept the build struct and set return value to DiscordID field
func (t *entParticipantTrait) SetDiscordIDLazy(fn func(ctx context.Context, i *EntParticipantMutator) (string, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.discordIDLazyMutateFunc(fn))
	return t
}

// SetDiscordIDDefault assign a default value to DiscordID field
func (t *entParticipantTrait) SetDiscordIDDefault(v string) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.discordIDDefaultMutateFunc(v))
	return t
}

// SetDiscordIDFactory register a factory function and assign return value to DiscordID, you can also use related factory's Create/CreateV as input function here
func (t *entParticipantTrait) SetDiscordIDFactory(fn func(ctx context.Context) (string, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.discordIDFactoryMutateFunc(fn))
	return t
}

func (*entParticipantMutation) iDSequenceMutateFunc(fn func(ctx context.Context, i int) (uuid.UUID, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.iDType = TypeSequence
		m.iDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetID(value)

			i.ID = value
			return nil
		}
	}
}
func (*entParticipantMutation) iDLazyMutateFunc(fn func(ctx context.Context, i *EntParticipantMutator) (uuid.UUID, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.iDType = TypeLazy
		m.iDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetID(value)

			i.ID = value
			return nil
		}
	}
}
func (*entParticipantMutation) iDDefaultMutateFunc(v uuid.UUID) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.iDType = TypeDefault
		m.iDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {

			i.EntCreator().SetID(v)

			i.ID = v
			return nil
		}
	}
}
func (*entParticipantMutation) iDFactoryMutateFunc(fn func(ctx context.Context) (uuid.UUID, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.iDType = TypeFactory
		m.iDFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetID(value)

			i.ID = value

			return nil
		}
	}
}

// SetIDSequence register a function which accept a sequence counter and set return value to ID field
func (f *EntParticipantMetaFactory) SetIDSequence(fn func(ctx context.Context, i int) (uuid.UUID, error)) *EntParticipantMetaFactory {
	f.mutation.iDSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetIDLazy register a function which accept the build struct and set return value to ID field
func (f *EntParticipantMetaFactory) SetIDLazy(fn func(ctx context.Context, i *EntParticipantMutator) (uuid.UUID, error)) *EntParticipantMetaFactory {
	f.mutation.iDLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetIDDefault assign a default value to ID field
func (f *EntParticipantMetaFactory) SetIDDefault(v uuid.UUID) *EntParticipantMetaFactory {
	f.mutation.iDDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetIDFactory register a factory function and assign return value to ID, you can also use related factory's Create/CreateV as input function here
func (f *EntParticipantMetaFactory) SetIDFactory(fn func(ctx context.Context) (uuid.UUID, error)) *EntParticipantMetaFactory {
	f.mutation.iDFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetIDSequence register a function which accept a sequence counter and set return value to ID field
func (t *entParticipantTrait) SetIDSequence(fn func(ctx context.Context, i int) (uuid.UUID, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.iDSequenceMutateFunc(fn))
	return t
}

// SetIDLazy register a function which accept the build struct and set return value to ID field
func (t *entParticipantTrait) SetIDLazy(fn func(ctx context.Context, i *EntParticipantMutator) (uuid.UUID, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.iDLazyMutateFunc(fn))
	return t
}

// SetIDDefault assign a default value to ID field
func (t *entParticipantTrait) SetIDDefault(v uuid.UUID) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.iDDefaultMutateFunc(v))
	return t
}

// SetIDFactory register a factory function and assign return value to ID, you can also use related factory's Create/CreateV as input function here
func (t *entParticipantTrait) SetIDFactory(fn func(ctx context.Context) (uuid.UUID, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.iDFactoryMutateFunc(fn))
	return t
}

func (*entParticipantMutation) vocationSequenceMutateFunc(fn func(ctx context.Context, i int) (participant.Vocation, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.vocationType = TypeSequence
		m.vocationFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetVocation(value)

			i.Vocation = value
			return nil
		}
	}
}
func (*entParticipantMutation) vocationLazyMutateFunc(fn func(ctx context.Context, i *EntParticipantMutator) (participant.Vocation, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.vocationType = TypeLazy
		m.vocationFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetVocation(value)

			i.Vocation = value
			return nil
		}
	}
}
func (*entParticipantMutation) vocationDefaultMutateFunc(v participant.Vocation) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.vocationType = TypeDefault
		m.vocationFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {

			i.EntCreator().SetVocation(v)

			i.Vocation = v
			return nil
		}
	}
}
func (*entParticipantMutation) vocationFactoryMutateFunc(fn func(ctx context.Context) (participant.Vocation, error)) func(m *entParticipantMutation) {
	return func(m *entParticipantMutation) {
		m.vocationType = TypeFactory
		m.vocationFunc = func(ctx context.Context, i *EntParticipantMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetVocation(value)

			i.Vocation = value

			return nil
		}
	}
}

// SetVocationSequence register a function which accept a sequence counter and set return value to Vocation field
func (f *EntParticipantMetaFactory) SetVocationSequence(fn func(ctx context.Context, i int) (participant.Vocation, error)) *EntParticipantMetaFactory {
	f.mutation.vocationSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetVocationLazy register a function which accept the build struct and set return value to Vocation field
func (f *EntParticipantMetaFactory) SetVocationLazy(fn func(ctx context.Context, i *EntParticipantMutator) (participant.Vocation, error)) *EntParticipantMetaFactory {
	f.mutation.vocationLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetVocationDefault assign a default value to Vocation field
func (f *EntParticipantMetaFactory) SetVocationDefault(v participant.Vocation) *EntParticipantMetaFactory {
	f.mutation.vocationDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetVocationFactory register a factory function and assign return value to Vocation, you can also use related factory's Create/CreateV as input function here
func (f *EntParticipantMetaFactory) SetVocationFactory(fn func(ctx context.Context) (participant.Vocation, error)) *EntParticipantMetaFactory {
	f.mutation.vocationFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetVocationSequence register a function which accept a sequence counter and set return value to Vocation field
func (t *entParticipantTrait) SetVocationSequence(fn func(ctx context.Context, i int) (participant.Vocation, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.vocationSequenceMutateFunc(fn))
	return t
}

// SetVocationLazy register a function which accept the build struct and set return value to Vocation field
func (t *entParticipantTrait) SetVocationLazy(fn func(ctx context.Context, i *EntParticipantMutator) (participant.Vocation, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.vocationLazyMutateFunc(fn))
	return t
}

// SetVocationDefault assign a default value to Vocation field
func (t *entParticipantTrait) SetVocationDefault(v participant.Vocation) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.vocationDefaultMutateFunc(v))
	return t
}

// SetVocationFactory register a factory function and assign return value to Vocation, you can also use related factory's Create/CreateV as input function here
func (t *entParticipantTrait) SetVocationFactory(fn func(ctx context.Context) (participant.Vocation, error)) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.vocationFactoryMutateFunc(fn))
	return t
}

// SetAfterCreateFunc register a function to be called after struct create
func (f *EntParticipantMetaFactory) SetAfterCreateFunc(fn func(ctx context.Context, i *ent.Participant) error) *EntParticipantMetaFactory {
	f.mutation.afterCreateFunc = fn
	return f
}

// SetBeforeCreateFunc register a function to be called before struct create
func (f *EntParticipantMetaFactory) SetBeforeCreateFunc(fn func(ctx context.Context, i *EntParticipantMutator) error) *EntParticipantMetaFactory {
	f.mutation.beforeCreateFunc = fn
	return f
}

// SetAfterCreateFunc register a function to be called after struct create
func (t *entParticipantTrait) SetAfterCreateFunc(fn func(ctx context.Context, i *ent.Participant) error) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.afterCreateMutateFunc(fn))
	return t
}

// SetBeforeCreateFunc register a function to be called before struct create
func (t *entParticipantTrait) SetBeforeCreateFunc(fn func(ctx context.Context, i *EntParticipantMutator) error) *entParticipantTrait {
	t.updates = append(t.updates, t.mutation.beforeCreateMutateFunc(fn))
	return t
}

// Build create a  EntParticipantFactory from EntParticipantMetaFactory
func (f *EntParticipantMetaFactory) Build() *EntParticipantFactory {
	return &EntParticipantFactory{meta: *f, counter: &Counter{}}
}

type EntParticipantFactory struct {
	meta    EntParticipantMetaFactory
	counter *Counter

	client *ent.Client
}

// SetBosslist set the Bosslist field
func (f *EntParticipantFactory) SetBosslist(i *ent.Bosslist) *EntParticipantBuilder {
	builder := &EntParticipantBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetBosslist(i)

	builder.client = f.client

	return builder
}

// SetBosslistID set the BosslistID field
func (f *EntParticipantFactory) SetBosslistID(i uuid.UUID) *EntParticipantBuilder {
	builder := &EntParticipantBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetBosslistID(i)

	builder.client = f.client

	return builder
}

// SetDiscordID set the DiscordID field
func (f *EntParticipantFactory) SetDiscordID(i string) *EntParticipantBuilder {
	builder := &EntParticipantBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetDiscordID(i)

	builder.client = f.client

	return builder
}

// SetID set the ID field
func (f *EntParticipantFactory) SetID(i uuid.UUID) *EntParticipantBuilder {
	builder := &EntParticipantBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetID(i)

	builder.client = f.client

	return builder
}

// SetVocation set the Vocation field
func (f *EntParticipantFactory) SetVocation(i participant.Vocation) *EntParticipantBuilder {
	builder := &EntParticipantBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetVocation(i)

	builder.client = f.client

	return builder
}

// Create return a new *ent.Participant
func (f *EntParticipantFactory) Create(ctx context.Context) (*ent.Participant, error) {
	builder := &EntParticipantBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.Create(ctx)
}

// CreateV return a new ent.Participant
func (f *EntParticipantFactory) CreateV(ctx context.Context) (ent.Participant, error) {
	builder := &EntParticipantBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.CreateV(ctx)
}

// CreateBatch return a []*ent.Participant slice
func (f *EntParticipantFactory) CreateBatch(ctx context.Context, n int) ([]*ent.Participant, error) {
	builder := &EntParticipantBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.CreateBatch(ctx, n)
}

// CreateBatchV return a []ent.Participant slice
func (f *EntParticipantFactory) CreateBatchV(ctx context.Context, n int) ([]ent.Participant, error) {
	builder := &EntParticipantBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.CreateBatchV(ctx, n)
}

// Client set ent client to EntParticipantFactory
func (f *EntParticipantFactory) Client(c *ent.Client) *EntParticipantFactory {
	f.client = c
	return f
}

type EntParticipantBuilder struct {
	factory  *EntParticipantFactory
	mutation entParticipantMutation
	counter  *Counter

	bosslistOverride  *ent.Bosslist
	bosslistOverriden bool

	bosslistIDOverride  uuid.UUID
	bosslistIDOverriden bool

	discordIDOverride  string
	discordIDOverriden bool

	iDOverride  uuid.UUID
	iDOverriden bool

	vocationOverride  participant.Vocation
	vocationOverriden bool

	client *ent.Client
}

func (b *EntParticipantBuilder) Client(c *ent.Client) *EntParticipantBuilder {
	b.client = c
	return b
}

// SetBosslist set the Bosslist field
func (b *EntParticipantBuilder) SetBosslist(i *ent.Bosslist) *EntParticipantBuilder {
	b.bosslistOverride = i
	b.bosslistOverriden = true
	return b
}

// SetBosslistID set the BosslistID field
func (b *EntParticipantBuilder) SetBosslistID(i uuid.UUID) *EntParticipantBuilder {
	b.bosslistIDOverride = i
	b.bosslistIDOverriden = true
	return b
}

// SetDiscordID set the DiscordID field
func (b *EntParticipantBuilder) SetDiscordID(i string) *EntParticipantBuilder {
	b.discordIDOverride = i
	b.discordIDOverriden = true
	return b
}

// SetID set the ID field
func (b *EntParticipantBuilder) SetID(i uuid.UUID) *EntParticipantBuilder {
	b.iDOverride = i
	b.iDOverriden = true
	return b
}

// SetVocation set the Vocation field
func (b *EntParticipantBuilder) SetVocation(i participant.Vocation) *EntParticipantBuilder {
	b.vocationOverride = i
	b.vocationOverriden = true
	return b
}

// CreateV return a new ent.Participant
func (b *EntParticipantBuilder) CreateV(ctx context.Context) (ent.Participant, error) {
	var d ent.Participant
	p, err := b.Create(ctx)
	if err == nil {
		d = *p
	}
	return d, err
}

// Create return a new *ent.Participant
func (b *EntParticipantBuilder) Create(ctx context.Context) (*ent.Participant, error) {

	var preSlice = []func(ctx context.Context, i *EntParticipantMutator, c int) error{}
	var lazySlice = []func(ctx context.Context, i *EntParticipantMutator, c int) error{}
	var postSlice = []func(ctx context.Context, i *ent.Participant, c int) error{}

	index := b.counter.Get()
	_ = index

	client := b.client
	entBuilder := client.Participant.Create()

	if b.bosslistOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntParticipantMutator, c int) error {
			value := b.bosslistOverride

			i.EntCreator().SetBosslist(value)

			i.Bosslist = value
			return nil
		})
	} else {
		switch b.mutation.bosslistType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.bosslistFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.bosslistFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.bosslistFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.bosslistFunc)
		}
	}

	if b.bosslistIDOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntParticipantMutator, c int) error {
			value := b.bosslistIDOverride

			i.EntCreator().SetBosslistID(value)

			i.BosslistID = value
			return nil
		})
	} else {
		switch b.mutation.bosslistIDType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.bosslistIDFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.bosslistIDFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.bosslistIDFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.bosslistIDFunc)
		}
	}

	if b.discordIDOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntParticipantMutator, c int) error {
			value := b.discordIDOverride

			i.EntCreator().SetDiscordID(value)

			i.DiscordID = value
			return nil
		})
	} else {
		switch b.mutation.discordIDType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.discordIDFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.discordIDFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.discordIDFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.discordIDFunc)
		}
	}

	if b.iDOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntParticipantMutator, c int) error {
			value := b.iDOverride

			i.EntCreator().SetID(value)

			i.ID = value
			return nil
		})
	} else {
		switch b.mutation.iDType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.iDFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.iDFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.iDFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.iDFunc)
		}
	}

	if b.vocationOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntParticipantMutator, c int) error {
			value := b.vocationOverride

			i.EntCreator().SetVocation(value)

			i.Vocation = value
			return nil
		})
	} else {
		switch b.mutation.vocationType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.vocationFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.vocationFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.vocationFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.vocationFunc)
		}
	}

	v := &EntParticipantMutator{}

	v._creator = entBuilder

	for _, f := range preSlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}
	for _, f := range lazySlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}
	if b.mutation.beforeCreateFunc != nil {
		if err := b.mutation.beforeCreateFunc(ctx, v); err != nil {
			return nil, err
		}
	}

	new, err := entBuilder.Save(ctx)
	if err != nil {
		return nil, err
	}

	if b.mutation.afterCreateFunc != nil {
		err := b.mutation.afterCreateFunc(ctx, new)
		if err != nil {
			return nil, err
		}
	}
	for _, f := range postSlice {
		err := f(ctx, new, index)
		if err != nil {
			return nil, err
		}
	}

	return new, nil
}
func (b *EntParticipantBuilder) CreateBatch(ctx context.Context, n int) ([]*ent.Participant, error) {
	var results []*ent.Participant
	for i := 0; i < n; i++ {
		d, err := b.Create(ctx)
		if err != nil {
			return results, err
		}
		results = append(results, d)
	}
	return results, nil
}
func (b *EntParticipantBuilder) CreateBatchV(ctx context.Context, n int) ([]ent.Participant, error) {
	var results []ent.Participant
	for i := 0; i < n; i++ {
		d, err := b.CreateV(ctx)
		if err != nil {
			return results, err
		}
		results = append(results, d)
	}
	return results, nil
}
