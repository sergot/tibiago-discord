// Code generated by carrier, DO NOT EDIT.
package factory

import (
	"github.com/sergot/tibiago/ent"

	"github.com/google/uuid"

	"context"
)

type EntInstanceConfigMutator struct {
	ID uuid.UUID

	Instance *ent.Instance

	InstanceID uuid.UUID

	Key string

	Value string

	_creator *ent.InstanceConfigCreate
}

func (m *EntInstanceConfigMutator) EntCreator() *ent.InstanceConfigCreate {
	return m._creator
}

type entInstanceConfigMutation struct {
	iDType int
	iDFunc func(ctx context.Context, i *EntInstanceConfigMutator, c int) error

	instanceType int
	instanceFunc func(ctx context.Context, i *EntInstanceConfigMutator, c int) error

	instanceIDType int
	instanceIDFunc func(ctx context.Context, i *EntInstanceConfigMutator, c int) error

	keyType int
	keyFunc func(ctx context.Context, i *EntInstanceConfigMutator, c int) error

	valueType int
	valueFunc func(ctx context.Context, i *EntInstanceConfigMutator, c int) error

	beforeCreateFunc func(ctx context.Context, i *EntInstanceConfigMutator) error
	afterCreateFunc  func(ctx context.Context, i *ent.InstanceConfig) error
}
type EntInstanceConfigMetaFactory struct {
	mutation entInstanceConfigMutation
}
type entInstanceConfigTrait struct {
	mutation entInstanceConfigMutation
	updates  []func(m *entInstanceConfigMutation)
}

func EntInstanceConfigTrait() *entInstanceConfigTrait {
	return &entInstanceConfigTrait{}
}
func (*entInstanceConfigMutation) beforeCreateMutateFunc(fn func(ctx context.Context, i *EntInstanceConfigMutator) error) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.beforeCreateFunc = fn
	}
}
func (*entInstanceConfigMutation) afterCreateMutateFunc(fn func(ctx context.Context, i *ent.InstanceConfig) error) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.afterCreateFunc = fn
	}
}

func (*entInstanceConfigMutation) iDSequenceMutateFunc(fn func(ctx context.Context, i int) (uuid.UUID, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.iDType = TypeSequence
		m.iDFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetID(value)

			i.ID = value
			return nil
		}
	}
}
func (*entInstanceConfigMutation) iDLazyMutateFunc(fn func(ctx context.Context, i *EntInstanceConfigMutator) (uuid.UUID, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.iDType = TypeLazy
		m.iDFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetID(value)

			i.ID = value
			return nil
		}
	}
}
func (*entInstanceConfigMutation) iDDefaultMutateFunc(v uuid.UUID) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.iDType = TypeDefault
		m.iDFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {

			i.EntCreator().SetID(v)

			i.ID = v
			return nil
		}
	}
}
func (*entInstanceConfigMutation) iDFactoryMutateFunc(fn func(ctx context.Context) (uuid.UUID, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.iDType = TypeFactory
		m.iDFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetID(value)

			i.ID = value

			return nil
		}
	}
}

// SetIDSequence register a function which accept a sequence counter and set return value to ID field
func (f *EntInstanceConfigMetaFactory) SetIDSequence(fn func(ctx context.Context, i int) (uuid.UUID, error)) *EntInstanceConfigMetaFactory {
	f.mutation.iDSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetIDLazy register a function which accept the build struct and set return value to ID field
func (f *EntInstanceConfigMetaFactory) SetIDLazy(fn func(ctx context.Context, i *EntInstanceConfigMutator) (uuid.UUID, error)) *EntInstanceConfigMetaFactory {
	f.mutation.iDLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetIDDefault assign a default value to ID field
func (f *EntInstanceConfigMetaFactory) SetIDDefault(v uuid.UUID) *EntInstanceConfigMetaFactory {
	f.mutation.iDDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetIDFactory register a factory function and assign return value to ID, you can also use related factory's Create/CreateV as input function here
func (f *EntInstanceConfigMetaFactory) SetIDFactory(fn func(ctx context.Context) (uuid.UUID, error)) *EntInstanceConfigMetaFactory {
	f.mutation.iDFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetIDSequence register a function which accept a sequence counter and set return value to ID field
func (t *entInstanceConfigTrait) SetIDSequence(fn func(ctx context.Context, i int) (uuid.UUID, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.iDSequenceMutateFunc(fn))
	return t
}

// SetIDLazy register a function which accept the build struct and set return value to ID field
func (t *entInstanceConfigTrait) SetIDLazy(fn func(ctx context.Context, i *EntInstanceConfigMutator) (uuid.UUID, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.iDLazyMutateFunc(fn))
	return t
}

// SetIDDefault assign a default value to ID field
func (t *entInstanceConfigTrait) SetIDDefault(v uuid.UUID) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.iDDefaultMutateFunc(v))
	return t
}

// SetIDFactory register a factory function and assign return value to ID, you can also use related factory's Create/CreateV as input function here
func (t *entInstanceConfigTrait) SetIDFactory(fn func(ctx context.Context) (uuid.UUID, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.iDFactoryMutateFunc(fn))
	return t
}

func (*entInstanceConfigMutation) instanceSequenceMutateFunc(fn func(ctx context.Context, i int) (*ent.Instance, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.instanceType = TypeSequence
		m.instanceFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetInstance(value)

			i.Instance = value
			return nil
		}
	}
}
func (*entInstanceConfigMutation) instanceLazyMutateFunc(fn func(ctx context.Context, i *EntInstanceConfigMutator) (*ent.Instance, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.instanceType = TypeLazy
		m.instanceFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetInstance(value)

			i.Instance = value
			return nil
		}
	}
}
func (*entInstanceConfigMutation) instanceDefaultMutateFunc(v *ent.Instance) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.instanceType = TypeDefault
		m.instanceFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {

			i.EntCreator().SetInstance(v)

			i.Instance = v
			return nil
		}
	}
}
func (*entInstanceConfigMutation) instanceFactoryMutateFunc(fn func(ctx context.Context) (*ent.Instance, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.instanceType = TypeFactory
		m.instanceFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetInstance(value)

			i.Instance = value

			return nil
		}
	}
}

// SetInstanceSequence register a function which accept a sequence counter and set return value to Instance field
func (f *EntInstanceConfigMetaFactory) SetInstanceSequence(fn func(ctx context.Context, i int) (*ent.Instance, error)) *EntInstanceConfigMetaFactory {
	f.mutation.instanceSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetInstanceLazy register a function which accept the build struct and set return value to Instance field
func (f *EntInstanceConfigMetaFactory) SetInstanceLazy(fn func(ctx context.Context, i *EntInstanceConfigMutator) (*ent.Instance, error)) *EntInstanceConfigMetaFactory {
	f.mutation.instanceLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetInstanceDefault assign a default value to Instance field
func (f *EntInstanceConfigMetaFactory) SetInstanceDefault(v *ent.Instance) *EntInstanceConfigMetaFactory {
	f.mutation.instanceDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetInstanceFactory register a factory function and assign return value to Instance, you can also use related factory's Create/CreateV as input function here
func (f *EntInstanceConfigMetaFactory) SetInstanceFactory(fn func(ctx context.Context) (*ent.Instance, error)) *EntInstanceConfigMetaFactory {
	f.mutation.instanceFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetInstanceSequence register a function which accept a sequence counter and set return value to Instance field
func (t *entInstanceConfigTrait) SetInstanceSequence(fn func(ctx context.Context, i int) (*ent.Instance, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.instanceSequenceMutateFunc(fn))
	return t
}

// SetInstanceLazy register a function which accept the build struct and set return value to Instance field
func (t *entInstanceConfigTrait) SetInstanceLazy(fn func(ctx context.Context, i *EntInstanceConfigMutator) (*ent.Instance, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.instanceLazyMutateFunc(fn))
	return t
}

// SetInstanceDefault assign a default value to Instance field
func (t *entInstanceConfigTrait) SetInstanceDefault(v *ent.Instance) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.instanceDefaultMutateFunc(v))
	return t
}

// SetInstanceFactory register a factory function and assign return value to Instance, you can also use related factory's Create/CreateV as input function here
func (t *entInstanceConfigTrait) SetInstanceFactory(fn func(ctx context.Context) (*ent.Instance, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.instanceFactoryMutateFunc(fn))
	return t
}

func (*entInstanceConfigMutation) instanceIDSequenceMutateFunc(fn func(ctx context.Context, i int) (uuid.UUID, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.instanceIDType = TypeSequence
		m.instanceIDFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetInstanceID(value)

			i.InstanceID = value
			return nil
		}
	}
}
func (*entInstanceConfigMutation) instanceIDLazyMutateFunc(fn func(ctx context.Context, i *EntInstanceConfigMutator) (uuid.UUID, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.instanceIDType = TypeLazy
		m.instanceIDFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetInstanceID(value)

			i.InstanceID = value
			return nil
		}
	}
}
func (*entInstanceConfigMutation) instanceIDDefaultMutateFunc(v uuid.UUID) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.instanceIDType = TypeDefault
		m.instanceIDFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {

			i.EntCreator().SetInstanceID(v)

			i.InstanceID = v
			return nil
		}
	}
}
func (*entInstanceConfigMutation) instanceIDFactoryMutateFunc(fn func(ctx context.Context) (uuid.UUID, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.instanceIDType = TypeFactory
		m.instanceIDFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetInstanceID(value)

			i.InstanceID = value

			return nil
		}
	}
}

// SetInstanceIDSequence register a function which accept a sequence counter and set return value to InstanceID field
func (f *EntInstanceConfigMetaFactory) SetInstanceIDSequence(fn func(ctx context.Context, i int) (uuid.UUID, error)) *EntInstanceConfigMetaFactory {
	f.mutation.instanceIDSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetInstanceIDLazy register a function which accept the build struct and set return value to InstanceID field
func (f *EntInstanceConfigMetaFactory) SetInstanceIDLazy(fn func(ctx context.Context, i *EntInstanceConfigMutator) (uuid.UUID, error)) *EntInstanceConfigMetaFactory {
	f.mutation.instanceIDLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetInstanceIDDefault assign a default value to InstanceID field
func (f *EntInstanceConfigMetaFactory) SetInstanceIDDefault(v uuid.UUID) *EntInstanceConfigMetaFactory {
	f.mutation.instanceIDDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetInstanceIDFactory register a factory function and assign return value to InstanceID, you can also use related factory's Create/CreateV as input function here
func (f *EntInstanceConfigMetaFactory) SetInstanceIDFactory(fn func(ctx context.Context) (uuid.UUID, error)) *EntInstanceConfigMetaFactory {
	f.mutation.instanceIDFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetInstanceIDSequence register a function which accept a sequence counter and set return value to InstanceID field
func (t *entInstanceConfigTrait) SetInstanceIDSequence(fn func(ctx context.Context, i int) (uuid.UUID, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.instanceIDSequenceMutateFunc(fn))
	return t
}

// SetInstanceIDLazy register a function which accept the build struct and set return value to InstanceID field
func (t *entInstanceConfigTrait) SetInstanceIDLazy(fn func(ctx context.Context, i *EntInstanceConfigMutator) (uuid.UUID, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.instanceIDLazyMutateFunc(fn))
	return t
}

// SetInstanceIDDefault assign a default value to InstanceID field
func (t *entInstanceConfigTrait) SetInstanceIDDefault(v uuid.UUID) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.instanceIDDefaultMutateFunc(v))
	return t
}

// SetInstanceIDFactory register a factory function and assign return value to InstanceID, you can also use related factory's Create/CreateV as input function here
func (t *entInstanceConfigTrait) SetInstanceIDFactory(fn func(ctx context.Context) (uuid.UUID, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.instanceIDFactoryMutateFunc(fn))
	return t
}

func (*entInstanceConfigMutation) keySequenceMutateFunc(fn func(ctx context.Context, i int) (string, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.keyType = TypeSequence
		m.keyFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetKey(value)

			i.Key = value
			return nil
		}
	}
}
func (*entInstanceConfigMutation) keyLazyMutateFunc(fn func(ctx context.Context, i *EntInstanceConfigMutator) (string, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.keyType = TypeLazy
		m.keyFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetKey(value)

			i.Key = value
			return nil
		}
	}
}
func (*entInstanceConfigMutation) keyDefaultMutateFunc(v string) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.keyType = TypeDefault
		m.keyFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {

			i.EntCreator().SetKey(v)

			i.Key = v
			return nil
		}
	}
}
func (*entInstanceConfigMutation) keyFactoryMutateFunc(fn func(ctx context.Context) (string, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.keyType = TypeFactory
		m.keyFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetKey(value)

			i.Key = value

			return nil
		}
	}
}

// SetKeySequence register a function which accept a sequence counter and set return value to Key field
func (f *EntInstanceConfigMetaFactory) SetKeySequence(fn func(ctx context.Context, i int) (string, error)) *EntInstanceConfigMetaFactory {
	f.mutation.keySequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetKeyLazy register a function which accept the build struct and set return value to Key field
func (f *EntInstanceConfigMetaFactory) SetKeyLazy(fn func(ctx context.Context, i *EntInstanceConfigMutator) (string, error)) *EntInstanceConfigMetaFactory {
	f.mutation.keyLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetKeyDefault assign a default value to Key field
func (f *EntInstanceConfigMetaFactory) SetKeyDefault(v string) *EntInstanceConfigMetaFactory {
	f.mutation.keyDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetKeyFactory register a factory function and assign return value to Key, you can also use related factory's Create/CreateV as input function here
func (f *EntInstanceConfigMetaFactory) SetKeyFactory(fn func(ctx context.Context) (string, error)) *EntInstanceConfigMetaFactory {
	f.mutation.keyFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetKeySequence register a function which accept a sequence counter and set return value to Key field
func (t *entInstanceConfigTrait) SetKeySequence(fn func(ctx context.Context, i int) (string, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.keySequenceMutateFunc(fn))
	return t
}

// SetKeyLazy register a function which accept the build struct and set return value to Key field
func (t *entInstanceConfigTrait) SetKeyLazy(fn func(ctx context.Context, i *EntInstanceConfigMutator) (string, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.keyLazyMutateFunc(fn))
	return t
}

// SetKeyDefault assign a default value to Key field
func (t *entInstanceConfigTrait) SetKeyDefault(v string) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.keyDefaultMutateFunc(v))
	return t
}

// SetKeyFactory register a factory function and assign return value to Key, you can also use related factory's Create/CreateV as input function here
func (t *entInstanceConfigTrait) SetKeyFactory(fn func(ctx context.Context) (string, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.keyFactoryMutateFunc(fn))
	return t
}

func (*entInstanceConfigMutation) valueSequenceMutateFunc(fn func(ctx context.Context, i int) (string, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.valueType = TypeSequence
		m.valueFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetValue(value)

			i.Value = value
			return nil
		}
	}
}
func (*entInstanceConfigMutation) valueLazyMutateFunc(fn func(ctx context.Context, i *EntInstanceConfigMutator) (string, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.valueType = TypeLazy
		m.valueFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetValue(value)

			i.Value = value
			return nil
		}
	}
}
func (*entInstanceConfigMutation) valueDefaultMutateFunc(v string) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.valueType = TypeDefault
		m.valueFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {

			i.EntCreator().SetValue(v)

			i.Value = v
			return nil
		}
	}
}
func (*entInstanceConfigMutation) valueFactoryMutateFunc(fn func(ctx context.Context) (string, error)) func(m *entInstanceConfigMutation) {
	return func(m *entInstanceConfigMutation) {
		m.valueType = TypeFactory
		m.valueFunc = func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetValue(value)

			i.Value = value

			return nil
		}
	}
}

// SetValueSequence register a function which accept a sequence counter and set return value to Value field
func (f *EntInstanceConfigMetaFactory) SetValueSequence(fn func(ctx context.Context, i int) (string, error)) *EntInstanceConfigMetaFactory {
	f.mutation.valueSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetValueLazy register a function which accept the build struct and set return value to Value field
func (f *EntInstanceConfigMetaFactory) SetValueLazy(fn func(ctx context.Context, i *EntInstanceConfigMutator) (string, error)) *EntInstanceConfigMetaFactory {
	f.mutation.valueLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetValueDefault assign a default value to Value field
func (f *EntInstanceConfigMetaFactory) SetValueDefault(v string) *EntInstanceConfigMetaFactory {
	f.mutation.valueDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetValueFactory register a factory function and assign return value to Value, you can also use related factory's Create/CreateV as input function here
func (f *EntInstanceConfigMetaFactory) SetValueFactory(fn func(ctx context.Context) (string, error)) *EntInstanceConfigMetaFactory {
	f.mutation.valueFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetValueSequence register a function which accept a sequence counter and set return value to Value field
func (t *entInstanceConfigTrait) SetValueSequence(fn func(ctx context.Context, i int) (string, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.valueSequenceMutateFunc(fn))
	return t
}

// SetValueLazy register a function which accept the build struct and set return value to Value field
func (t *entInstanceConfigTrait) SetValueLazy(fn func(ctx context.Context, i *EntInstanceConfigMutator) (string, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.valueLazyMutateFunc(fn))
	return t
}

// SetValueDefault assign a default value to Value field
func (t *entInstanceConfigTrait) SetValueDefault(v string) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.valueDefaultMutateFunc(v))
	return t
}

// SetValueFactory register a factory function and assign return value to Value, you can also use related factory's Create/CreateV as input function here
func (t *entInstanceConfigTrait) SetValueFactory(fn func(ctx context.Context) (string, error)) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.valueFactoryMutateFunc(fn))
	return t
}

// SetAfterCreateFunc register a function to be called after struct create
func (f *EntInstanceConfigMetaFactory) SetAfterCreateFunc(fn func(ctx context.Context, i *ent.InstanceConfig) error) *EntInstanceConfigMetaFactory {
	f.mutation.afterCreateFunc = fn
	return f
}

// SetBeforeCreateFunc register a function to be called before struct create
func (f *EntInstanceConfigMetaFactory) SetBeforeCreateFunc(fn func(ctx context.Context, i *EntInstanceConfigMutator) error) *EntInstanceConfigMetaFactory {
	f.mutation.beforeCreateFunc = fn
	return f
}

// SetAfterCreateFunc register a function to be called after struct create
func (t *entInstanceConfigTrait) SetAfterCreateFunc(fn func(ctx context.Context, i *ent.InstanceConfig) error) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.afterCreateMutateFunc(fn))
	return t
}

// SetBeforeCreateFunc register a function to be called before struct create
func (t *entInstanceConfigTrait) SetBeforeCreateFunc(fn func(ctx context.Context, i *EntInstanceConfigMutator) error) *entInstanceConfigTrait {
	t.updates = append(t.updates, t.mutation.beforeCreateMutateFunc(fn))
	return t
}

// Build create a  EntInstanceConfigFactory from EntInstanceConfigMetaFactory
func (f *EntInstanceConfigMetaFactory) Build() *EntInstanceConfigFactory {
	return &EntInstanceConfigFactory{meta: *f, counter: &Counter{}}
}

type EntInstanceConfigFactory struct {
	meta    EntInstanceConfigMetaFactory
	counter *Counter

	client *ent.Client
}

// SetID set the ID field
func (f *EntInstanceConfigFactory) SetID(i uuid.UUID) *EntInstanceConfigBuilder {
	builder := &EntInstanceConfigBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetID(i)

	builder.client = f.client

	return builder
}

// SetInstance set the Instance field
func (f *EntInstanceConfigFactory) SetInstance(i *ent.Instance) *EntInstanceConfigBuilder {
	builder := &EntInstanceConfigBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetInstance(i)

	builder.client = f.client

	return builder
}

// SetInstanceID set the InstanceID field
func (f *EntInstanceConfigFactory) SetInstanceID(i uuid.UUID) *EntInstanceConfigBuilder {
	builder := &EntInstanceConfigBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetInstanceID(i)

	builder.client = f.client

	return builder
}

// SetKey set the Key field
func (f *EntInstanceConfigFactory) SetKey(i string) *EntInstanceConfigBuilder {
	builder := &EntInstanceConfigBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetKey(i)

	builder.client = f.client

	return builder
}

// SetValue set the Value field
func (f *EntInstanceConfigFactory) SetValue(i string) *EntInstanceConfigBuilder {
	builder := &EntInstanceConfigBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetValue(i)

	builder.client = f.client

	return builder
}

// Create return a new *ent.InstanceConfig
func (f *EntInstanceConfigFactory) Create(ctx context.Context) (*ent.InstanceConfig, error) {
	builder := &EntInstanceConfigBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.Create(ctx)
}

// CreateV return a new ent.InstanceConfig
func (f *EntInstanceConfigFactory) CreateV(ctx context.Context) (ent.InstanceConfig, error) {
	builder := &EntInstanceConfigBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.CreateV(ctx)
}

// CreateBatch return a []*ent.InstanceConfig slice
func (f *EntInstanceConfigFactory) CreateBatch(ctx context.Context, n int) ([]*ent.InstanceConfig, error) {
	builder := &EntInstanceConfigBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.CreateBatch(ctx, n)
}

// CreateBatchV return a []ent.InstanceConfig slice
func (f *EntInstanceConfigFactory) CreateBatchV(ctx context.Context, n int) ([]ent.InstanceConfig, error) {
	builder := &EntInstanceConfigBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.CreateBatchV(ctx, n)
}

// Client set ent client to EntInstanceConfigFactory
func (f *EntInstanceConfigFactory) Client(c *ent.Client) *EntInstanceConfigFactory {
	f.client = c
	return f
}

type EntInstanceConfigBuilder struct {
	factory  *EntInstanceConfigFactory
	mutation entInstanceConfigMutation
	counter  *Counter

	iDOverride  uuid.UUID
	iDOverriden bool

	instanceOverride  *ent.Instance
	instanceOverriden bool

	instanceIDOverride  uuid.UUID
	instanceIDOverriden bool

	keyOverride  string
	keyOverriden bool

	valueOverride  string
	valueOverriden bool

	client *ent.Client
}

func (b *EntInstanceConfigBuilder) Client(c *ent.Client) *EntInstanceConfigBuilder {
	b.client = c
	return b
}

// SetID set the ID field
func (b *EntInstanceConfigBuilder) SetID(i uuid.UUID) *EntInstanceConfigBuilder {
	b.iDOverride = i
	b.iDOverriden = true
	return b
}

// SetInstance set the Instance field
func (b *EntInstanceConfigBuilder) SetInstance(i *ent.Instance) *EntInstanceConfigBuilder {
	b.instanceOverride = i
	b.instanceOverriden = true
	return b
}

// SetInstanceID set the InstanceID field
func (b *EntInstanceConfigBuilder) SetInstanceID(i uuid.UUID) *EntInstanceConfigBuilder {
	b.instanceIDOverride = i
	b.instanceIDOverriden = true
	return b
}

// SetKey set the Key field
func (b *EntInstanceConfigBuilder) SetKey(i string) *EntInstanceConfigBuilder {
	b.keyOverride = i
	b.keyOverriden = true
	return b
}

// SetValue set the Value field
func (b *EntInstanceConfigBuilder) SetValue(i string) *EntInstanceConfigBuilder {
	b.valueOverride = i
	b.valueOverriden = true
	return b
}

// CreateV return a new ent.InstanceConfig
func (b *EntInstanceConfigBuilder) CreateV(ctx context.Context) (ent.InstanceConfig, error) {
	var d ent.InstanceConfig
	p, err := b.Create(ctx)
	if err == nil {
		d = *p
	}
	return d, err
}

// Create return a new *ent.InstanceConfig
func (b *EntInstanceConfigBuilder) Create(ctx context.Context) (*ent.InstanceConfig, error) {

	var preSlice = []func(ctx context.Context, i *EntInstanceConfigMutator, c int) error{}
	var lazySlice = []func(ctx context.Context, i *EntInstanceConfigMutator, c int) error{}
	var postSlice = []func(ctx context.Context, i *ent.InstanceConfig, c int) error{}

	index := b.counter.Get()
	_ = index

	client := b.client
	entBuilder := client.InstanceConfig.Create()

	if b.iDOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			value := b.iDOverride

			i.EntCreator().SetID(value)

			i.ID = value
			return nil
		})
	} else {
		switch b.mutation.iDType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.iDFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.iDFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.iDFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.iDFunc)
		}
	}

	if b.instanceOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			value := b.instanceOverride

			i.EntCreator().SetInstance(value)

			i.Instance = value
			return nil
		})
	} else {
		switch b.mutation.instanceType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.instanceFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.instanceFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.instanceFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.instanceFunc)
		}
	}

	if b.instanceIDOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			value := b.instanceIDOverride

			i.EntCreator().SetInstanceID(value)

			i.InstanceID = value
			return nil
		})
	} else {
		switch b.mutation.instanceIDType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.instanceIDFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.instanceIDFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.instanceIDFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.instanceIDFunc)
		}
	}

	if b.keyOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			value := b.keyOverride

			i.EntCreator().SetKey(value)

			i.Key = value
			return nil
		})
	} else {
		switch b.mutation.keyType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.keyFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.keyFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.keyFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.keyFunc)
		}
	}

	if b.valueOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntInstanceConfigMutator, c int) error {
			value := b.valueOverride

			i.EntCreator().SetValue(value)

			i.Value = value
			return nil
		})
	} else {
		switch b.mutation.valueType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.valueFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.valueFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.valueFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.valueFunc)
		}
	}

	v := &EntInstanceConfigMutator{}

	v._creator = entBuilder

	for _, f := range preSlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}
	for _, f := range lazySlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}
	if b.mutation.beforeCreateFunc != nil {
		if err := b.mutation.beforeCreateFunc(ctx, v); err != nil {
			return nil, err
		}
	}

	new, err := entBuilder.Save(ctx)
	if err != nil {
		return nil, err
	}

	if b.mutation.afterCreateFunc != nil {
		err := b.mutation.afterCreateFunc(ctx, new)
		if err != nil {
			return nil, err
		}
	}
	for _, f := range postSlice {
		err := f(ctx, new, index)
		if err != nil {
			return nil, err
		}
	}

	return new, nil
}
func (b *EntInstanceConfigBuilder) CreateBatch(ctx context.Context, n int) ([]*ent.InstanceConfig, error) {
	var results []*ent.InstanceConfig
	for i := 0; i < n; i++ {
		d, err := b.Create(ctx)
		if err != nil {
			return results, err
		}
		results = append(results, d)
	}
	return results, nil
}
func (b *EntInstanceConfigBuilder) CreateBatchV(ctx context.Context, n int) ([]ent.InstanceConfig, error) {
	var results []ent.InstanceConfig
	for i := 0; i < n; i++ {
		d, err := b.CreateV(ctx)
		if err != nil {
			return results, err
		}
		results = append(results, d)
	}
	return results, nil
}
