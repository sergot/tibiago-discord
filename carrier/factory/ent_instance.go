// Code generated by carrier, DO NOT EDIT.
package factory

import (
	"github.com/sergot/tibiago/ent"

	"github.com/google/uuid"

	"github.com/sergot/tibiago/ent/instance"

	"context"
)

type EntInstanceMutator struct {
	DiscordGuildID string

	ID uuid.UUID

	Status instance.Status

	_creator *ent.InstanceCreate
}

func (m *EntInstanceMutator) EntCreator() *ent.InstanceCreate {
	return m._creator
}

type entInstanceMutation struct {
	discordGuildIDType int
	discordGuildIDFunc func(ctx context.Context, i *EntInstanceMutator, c int) error

	iDType int
	iDFunc func(ctx context.Context, i *EntInstanceMutator, c int) error

	statusType int
	statusFunc func(ctx context.Context, i *EntInstanceMutator, c int) error

	beforeCreateFunc func(ctx context.Context, i *EntInstanceMutator) error
	afterCreateFunc  func(ctx context.Context, i *ent.Instance) error
}
type EntInstanceMetaFactory struct {
	mutation entInstanceMutation
}
type entInstanceTrait struct {
	mutation entInstanceMutation
	updates  []func(m *entInstanceMutation)
}

func EntInstanceTrait() *entInstanceTrait {
	return &entInstanceTrait{}
}
func (*entInstanceMutation) beforeCreateMutateFunc(fn func(ctx context.Context, i *EntInstanceMutator) error) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.beforeCreateFunc = fn
	}
}
func (*entInstanceMutation) afterCreateMutateFunc(fn func(ctx context.Context, i *ent.Instance) error) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.afterCreateFunc = fn
	}
}

func (*entInstanceMutation) discordGuildIDSequenceMutateFunc(fn func(ctx context.Context, i int) (string, error)) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.discordGuildIDType = TypeSequence
		m.discordGuildIDFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetDiscordGuildID(value)

			i.DiscordGuildID = value
			return nil
		}
	}
}
func (*entInstanceMutation) discordGuildIDLazyMutateFunc(fn func(ctx context.Context, i *EntInstanceMutator) (string, error)) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.discordGuildIDType = TypeLazy
		m.discordGuildIDFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetDiscordGuildID(value)

			i.DiscordGuildID = value
			return nil
		}
	}
}
func (*entInstanceMutation) discordGuildIDDefaultMutateFunc(v string) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.discordGuildIDType = TypeDefault
		m.discordGuildIDFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {

			i.EntCreator().SetDiscordGuildID(v)

			i.DiscordGuildID = v
			return nil
		}
	}
}
func (*entInstanceMutation) discordGuildIDFactoryMutateFunc(fn func(ctx context.Context) (string, error)) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.discordGuildIDType = TypeFactory
		m.discordGuildIDFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetDiscordGuildID(value)

			i.DiscordGuildID = value

			return nil
		}
	}
}

// SetDiscordGuildIDSequence register a function which accept a sequence counter and set return value to DiscordGuildID field
func (f *EntInstanceMetaFactory) SetDiscordGuildIDSequence(fn func(ctx context.Context, i int) (string, error)) *EntInstanceMetaFactory {
	f.mutation.discordGuildIDSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetDiscordGuildIDLazy register a function which accept the build struct and set return value to DiscordGuildID field
func (f *EntInstanceMetaFactory) SetDiscordGuildIDLazy(fn func(ctx context.Context, i *EntInstanceMutator) (string, error)) *EntInstanceMetaFactory {
	f.mutation.discordGuildIDLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetDiscordGuildIDDefault assign a default value to DiscordGuildID field
func (f *EntInstanceMetaFactory) SetDiscordGuildIDDefault(v string) *EntInstanceMetaFactory {
	f.mutation.discordGuildIDDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetDiscordGuildIDFactory register a factory function and assign return value to DiscordGuildID, you can also use related factory's Create/CreateV as input function here
func (f *EntInstanceMetaFactory) SetDiscordGuildIDFactory(fn func(ctx context.Context) (string, error)) *EntInstanceMetaFactory {
	f.mutation.discordGuildIDFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetDiscordGuildIDSequence register a function which accept a sequence counter and set return value to DiscordGuildID field
func (t *entInstanceTrait) SetDiscordGuildIDSequence(fn func(ctx context.Context, i int) (string, error)) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.discordGuildIDSequenceMutateFunc(fn))
	return t
}

// SetDiscordGuildIDLazy register a function which accept the build struct and set return value to DiscordGuildID field
func (t *entInstanceTrait) SetDiscordGuildIDLazy(fn func(ctx context.Context, i *EntInstanceMutator) (string, error)) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.discordGuildIDLazyMutateFunc(fn))
	return t
}

// SetDiscordGuildIDDefault assign a default value to DiscordGuildID field
func (t *entInstanceTrait) SetDiscordGuildIDDefault(v string) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.discordGuildIDDefaultMutateFunc(v))
	return t
}

// SetDiscordGuildIDFactory register a factory function and assign return value to DiscordGuildID, you can also use related factory's Create/CreateV as input function here
func (t *entInstanceTrait) SetDiscordGuildIDFactory(fn func(ctx context.Context) (string, error)) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.discordGuildIDFactoryMutateFunc(fn))
	return t
}

func (*entInstanceMutation) iDSequenceMutateFunc(fn func(ctx context.Context, i int) (uuid.UUID, error)) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.iDType = TypeSequence
		m.iDFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetID(value)

			i.ID = value
			return nil
		}
	}
}
func (*entInstanceMutation) iDLazyMutateFunc(fn func(ctx context.Context, i *EntInstanceMutator) (uuid.UUID, error)) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.iDType = TypeLazy
		m.iDFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetID(value)

			i.ID = value
			return nil
		}
	}
}
func (*entInstanceMutation) iDDefaultMutateFunc(v uuid.UUID) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.iDType = TypeDefault
		m.iDFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {

			i.EntCreator().SetID(v)

			i.ID = v
			return nil
		}
	}
}
func (*entInstanceMutation) iDFactoryMutateFunc(fn func(ctx context.Context) (uuid.UUID, error)) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.iDType = TypeFactory
		m.iDFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetID(value)

			i.ID = value

			return nil
		}
	}
}

// SetIDSequence register a function which accept a sequence counter and set return value to ID field
func (f *EntInstanceMetaFactory) SetIDSequence(fn func(ctx context.Context, i int) (uuid.UUID, error)) *EntInstanceMetaFactory {
	f.mutation.iDSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetIDLazy register a function which accept the build struct and set return value to ID field
func (f *EntInstanceMetaFactory) SetIDLazy(fn func(ctx context.Context, i *EntInstanceMutator) (uuid.UUID, error)) *EntInstanceMetaFactory {
	f.mutation.iDLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetIDDefault assign a default value to ID field
func (f *EntInstanceMetaFactory) SetIDDefault(v uuid.UUID) *EntInstanceMetaFactory {
	f.mutation.iDDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetIDFactory register a factory function and assign return value to ID, you can also use related factory's Create/CreateV as input function here
func (f *EntInstanceMetaFactory) SetIDFactory(fn func(ctx context.Context) (uuid.UUID, error)) *EntInstanceMetaFactory {
	f.mutation.iDFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetIDSequence register a function which accept a sequence counter and set return value to ID field
func (t *entInstanceTrait) SetIDSequence(fn func(ctx context.Context, i int) (uuid.UUID, error)) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.iDSequenceMutateFunc(fn))
	return t
}

// SetIDLazy register a function which accept the build struct and set return value to ID field
func (t *entInstanceTrait) SetIDLazy(fn func(ctx context.Context, i *EntInstanceMutator) (uuid.UUID, error)) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.iDLazyMutateFunc(fn))
	return t
}

// SetIDDefault assign a default value to ID field
func (t *entInstanceTrait) SetIDDefault(v uuid.UUID) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.iDDefaultMutateFunc(v))
	return t
}

// SetIDFactory register a factory function and assign return value to ID, you can also use related factory's Create/CreateV as input function here
func (t *entInstanceTrait) SetIDFactory(fn func(ctx context.Context) (uuid.UUID, error)) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.iDFactoryMutateFunc(fn))
	return t
}

func (*entInstanceMutation) statusSequenceMutateFunc(fn func(ctx context.Context, i int) (instance.Status, error)) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.statusType = TypeSequence
		m.statusFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, c)
			if err != nil {
				return err
			}

			i.EntCreator().SetStatus(value)

			i.Status = value
			return nil
		}
	}
}
func (*entInstanceMutation) statusLazyMutateFunc(fn func(ctx context.Context, i *EntInstanceMutator) (instance.Status, error)) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.statusType = TypeLazy
		m.statusFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx, i)
			if err != nil {
				return err
			}

			i.EntCreator().SetStatus(value)

			i.Status = value
			return nil
		}
	}
}
func (*entInstanceMutation) statusDefaultMutateFunc(v instance.Status) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.statusType = TypeDefault
		m.statusFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {

			i.EntCreator().SetStatus(v)

			i.Status = v
			return nil
		}
	}
}
func (*entInstanceMutation) statusFactoryMutateFunc(fn func(ctx context.Context) (instance.Status, error)) func(m *entInstanceMutation) {
	return func(m *entInstanceMutation) {
		m.statusType = TypeFactory
		m.statusFunc = func(ctx context.Context, i *EntInstanceMutator, c int) error {
			if fn == nil {
				return nil
			}
			value, err := fn(ctx)
			if err != nil {
				return err
			}

			i.EntCreator().SetStatus(value)

			i.Status = value

			return nil
		}
	}
}

// SetStatusSequence register a function which accept a sequence counter and set return value to Status field
func (f *EntInstanceMetaFactory) SetStatusSequence(fn func(ctx context.Context, i int) (instance.Status, error)) *EntInstanceMetaFactory {
	f.mutation.statusSequenceMutateFunc(fn)(&f.mutation)
	return f
}

// SetStatusLazy register a function which accept the build struct and set return value to Status field
func (f *EntInstanceMetaFactory) SetStatusLazy(fn func(ctx context.Context, i *EntInstanceMutator) (instance.Status, error)) *EntInstanceMetaFactory {
	f.mutation.statusLazyMutateFunc(fn)(&f.mutation)
	return f
}

// SetStatusDefault assign a default value to Status field
func (f *EntInstanceMetaFactory) SetStatusDefault(v instance.Status) *EntInstanceMetaFactory {
	f.mutation.statusDefaultMutateFunc(v)(&f.mutation)
	return f
}

// SetStatusFactory register a factory function and assign return value to Status, you can also use related factory's Create/CreateV as input function here
func (f *EntInstanceMetaFactory) SetStatusFactory(fn func(ctx context.Context) (instance.Status, error)) *EntInstanceMetaFactory {
	f.mutation.statusFactoryMutateFunc(fn)(&f.mutation)
	return f
}

// SetStatusSequence register a function which accept a sequence counter and set return value to Status field
func (t *entInstanceTrait) SetStatusSequence(fn func(ctx context.Context, i int) (instance.Status, error)) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.statusSequenceMutateFunc(fn))
	return t
}

// SetStatusLazy register a function which accept the build struct and set return value to Status field
func (t *entInstanceTrait) SetStatusLazy(fn func(ctx context.Context, i *EntInstanceMutator) (instance.Status, error)) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.statusLazyMutateFunc(fn))
	return t
}

// SetStatusDefault assign a default value to Status field
func (t *entInstanceTrait) SetStatusDefault(v instance.Status) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.statusDefaultMutateFunc(v))
	return t
}

// SetStatusFactory register a factory function and assign return value to Status, you can also use related factory's Create/CreateV as input function here
func (t *entInstanceTrait) SetStatusFactory(fn func(ctx context.Context) (instance.Status, error)) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.statusFactoryMutateFunc(fn))
	return t
}

// SetAfterCreateFunc register a function to be called after struct create
func (f *EntInstanceMetaFactory) SetAfterCreateFunc(fn func(ctx context.Context, i *ent.Instance) error) *EntInstanceMetaFactory {
	f.mutation.afterCreateFunc = fn
	return f
}

// SetBeforeCreateFunc register a function to be called before struct create
func (f *EntInstanceMetaFactory) SetBeforeCreateFunc(fn func(ctx context.Context, i *EntInstanceMutator) error) *EntInstanceMetaFactory {
	f.mutation.beforeCreateFunc = fn
	return f
}

// SetAfterCreateFunc register a function to be called after struct create
func (t *entInstanceTrait) SetAfterCreateFunc(fn func(ctx context.Context, i *ent.Instance) error) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.afterCreateMutateFunc(fn))
	return t
}

// SetBeforeCreateFunc register a function to be called before struct create
func (t *entInstanceTrait) SetBeforeCreateFunc(fn func(ctx context.Context, i *EntInstanceMutator) error) *entInstanceTrait {
	t.updates = append(t.updates, t.mutation.beforeCreateMutateFunc(fn))
	return t
}

// Build create a  EntInstanceFactory from EntInstanceMetaFactory
func (f *EntInstanceMetaFactory) Build() *EntInstanceFactory {
	return &EntInstanceFactory{meta: *f, counter: &Counter{}}
}

type EntInstanceFactory struct {
	meta    EntInstanceMetaFactory
	counter *Counter

	client *ent.Client
}

// SetDiscordGuildID set the DiscordGuildID field
func (f *EntInstanceFactory) SetDiscordGuildID(i string) *EntInstanceBuilder {
	builder := &EntInstanceBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetDiscordGuildID(i)

	builder.client = f.client

	return builder
}

// SetID set the ID field
func (f *EntInstanceFactory) SetID(i uuid.UUID) *EntInstanceBuilder {
	builder := &EntInstanceBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetID(i)

	builder.client = f.client

	return builder
}

// SetStatus set the Status field
func (f *EntInstanceFactory) SetStatus(i instance.Status) *EntInstanceBuilder {
	builder := &EntInstanceBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}
	builder.SetStatus(i)

	builder.client = f.client

	return builder
}

// Create return a new *ent.Instance
func (f *EntInstanceFactory) Create(ctx context.Context) (*ent.Instance, error) {
	builder := &EntInstanceBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.Create(ctx)
}

// CreateV return a new ent.Instance
func (f *EntInstanceFactory) CreateV(ctx context.Context) (ent.Instance, error) {
	builder := &EntInstanceBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.CreateV(ctx)
}

// CreateBatch return a []*ent.Instance slice
func (f *EntInstanceFactory) CreateBatch(ctx context.Context, n int) ([]*ent.Instance, error) {
	builder := &EntInstanceBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.CreateBatch(ctx, n)
}

// CreateBatchV return a []ent.Instance slice
func (f *EntInstanceFactory) CreateBatchV(ctx context.Context, n int) ([]ent.Instance, error) {
	builder := &EntInstanceBuilder{mutation: f.meta.mutation, counter: f.counter, factory: f}

	builder.client = f.client

	return builder.CreateBatchV(ctx, n)
}

// Client set ent client to EntInstanceFactory
func (f *EntInstanceFactory) Client(c *ent.Client) *EntInstanceFactory {
	f.client = c
	return f
}

type EntInstanceBuilder struct {
	factory  *EntInstanceFactory
	mutation entInstanceMutation
	counter  *Counter

	discordGuildIDOverride  string
	discordGuildIDOverriden bool

	iDOverride  uuid.UUID
	iDOverriden bool

	statusOverride  instance.Status
	statusOverriden bool

	client *ent.Client
}

func (b *EntInstanceBuilder) Client(c *ent.Client) *EntInstanceBuilder {
	b.client = c
	return b
}

// SetDiscordGuildID set the DiscordGuildID field
func (b *EntInstanceBuilder) SetDiscordGuildID(i string) *EntInstanceBuilder {
	b.discordGuildIDOverride = i
	b.discordGuildIDOverriden = true
	return b
}

// SetID set the ID field
func (b *EntInstanceBuilder) SetID(i uuid.UUID) *EntInstanceBuilder {
	b.iDOverride = i
	b.iDOverriden = true
	return b
}

// SetStatus set the Status field
func (b *EntInstanceBuilder) SetStatus(i instance.Status) *EntInstanceBuilder {
	b.statusOverride = i
	b.statusOverriden = true
	return b
}

// CreateV return a new ent.Instance
func (b *EntInstanceBuilder) CreateV(ctx context.Context) (ent.Instance, error) {
	var d ent.Instance
	p, err := b.Create(ctx)
	if err == nil {
		d = *p
	}
	return d, err
}

// Create return a new *ent.Instance
func (b *EntInstanceBuilder) Create(ctx context.Context) (*ent.Instance, error) {

	var preSlice = []func(ctx context.Context, i *EntInstanceMutator, c int) error{}
	var lazySlice = []func(ctx context.Context, i *EntInstanceMutator, c int) error{}
	var postSlice = []func(ctx context.Context, i *ent.Instance, c int) error{}

	index := b.counter.Get()
	_ = index

	client := b.client
	entBuilder := client.Instance.Create()

	if b.discordGuildIDOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntInstanceMutator, c int) error {
			value := b.discordGuildIDOverride

			i.EntCreator().SetDiscordGuildID(value)

			i.DiscordGuildID = value
			return nil
		})
	} else {
		switch b.mutation.discordGuildIDType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.discordGuildIDFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.discordGuildIDFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.discordGuildIDFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.discordGuildIDFunc)
		}
	}

	if b.iDOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntInstanceMutator, c int) error {
			value := b.iDOverride

			i.EntCreator().SetID(value)

			i.ID = value
			return nil
		})
	} else {
		switch b.mutation.iDType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.iDFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.iDFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.iDFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.iDFunc)
		}
	}

	if b.statusOverriden {
		preSlice = append(preSlice, func(ctx context.Context, i *EntInstanceMutator, c int) error {
			value := b.statusOverride

			i.EntCreator().SetStatus(value)

			i.Status = value
			return nil
		})
	} else {
		switch b.mutation.statusType {
		case TypeDefault:
			preSlice = append(preSlice, b.mutation.statusFunc)
		case TypeLazy:
			lazySlice = append(lazySlice, b.mutation.statusFunc)
		case TypeSequence:
			preSlice = append(preSlice, b.mutation.statusFunc)
		case TypeFactory:
			preSlice = append(preSlice, b.mutation.statusFunc)
		}
	}

	v := &EntInstanceMutator{}

	v._creator = entBuilder

	for _, f := range preSlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}
	for _, f := range lazySlice {

		err := f(ctx, v, index)

		if err != nil {
			return nil, err
		}
	}
	if b.mutation.beforeCreateFunc != nil {
		if err := b.mutation.beforeCreateFunc(ctx, v); err != nil {
			return nil, err
		}
	}

	new, err := entBuilder.Save(ctx)
	if err != nil {
		return nil, err
	}

	if b.mutation.afterCreateFunc != nil {
		err := b.mutation.afterCreateFunc(ctx, new)
		if err != nil {
			return nil, err
		}
	}
	for _, f := range postSlice {
		err := f(ctx, new, index)
		if err != nil {
			return nil, err
		}
	}

	return new, nil
}
func (b *EntInstanceBuilder) CreateBatch(ctx context.Context, n int) ([]*ent.Instance, error) {
	var results []*ent.Instance
	for i := 0; i < n; i++ {
		d, err := b.Create(ctx)
		if err != nil {
			return results, err
		}
		results = append(results, d)
	}
	return results, nil
}
func (b *EntInstanceBuilder) CreateBatchV(ctx context.Context, n int) ([]ent.Instance, error) {
	var results []ent.Instance
	for i := 0; i < n; i++ {
		d, err := b.CreateV(ctx)
		if err != nil {
			return results, err
		}
		results = append(results, d)
	}
	return results, nil
}
