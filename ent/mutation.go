// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/sergot/tibiago/ent/boss"
	"github.com/sergot/tibiago/ent/bosslist"
	"github.com/sergot/tibiago/ent/instance"
	"github.com/sergot/tibiago/ent/instanceconfig"
	"github.com/sergot/tibiago/ent/participant"
	"github.com/sergot/tibiago/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBoss           = "Boss"
	TypeBosslist       = "Bosslist"
	TypeInstance       = "Instance"
	TypeInstanceConfig = "InstanceConfig"
	TypeParticipant    = "Participant"
)

// BossMutation represents an operation that mutates the Boss nodes in the graph.
type BossMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	template         *string
	clearedFields    map[string]struct{}
	bosslists        map[uuid.UUID]struct{}
	removedbosslists map[uuid.UUID]struct{}
	clearedbosslists bool
	done             bool
	oldValue         func(context.Context) (*Boss, error)
	predicates       []predicate.Boss
}

var _ ent.Mutation = (*BossMutation)(nil)

// bossOption allows management of the mutation configuration using functional options.
type bossOption func(*BossMutation)

// newBossMutation creates new mutation for the Boss entity.
func newBossMutation(c config, op Op, opts ...bossOption) *BossMutation {
	m := &BossMutation{
		config:        c,
		op:            op,
		typ:           TypeBoss,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBossID sets the ID field of the mutation.
func withBossID(id uuid.UUID) bossOption {
	return func(m *BossMutation) {
		var (
			err   error
			once  sync.Once
			value *Boss
		)
		m.oldValue = func(ctx context.Context) (*Boss, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Boss.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBoss sets the old Boss of the mutation.
func withBoss(node *Boss) bossOption {
	return func(m *BossMutation) {
		m.oldValue = func(context.Context) (*Boss, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BossMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BossMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Boss entities.
func (m *BossMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BossMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BossMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Boss.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BossMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BossMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Boss entity.
// If the Boss object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BossMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BossMutation) ResetName() {
	m.name = nil
}

// SetTemplate sets the "template" field.
func (m *BossMutation) SetTemplate(s string) {
	m.template = &s
}

// Template returns the value of the "template" field in the mutation.
func (m *BossMutation) Template() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the Boss entity.
// If the Boss object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BossMutation) OldTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *BossMutation) ResetTemplate() {
	m.template = nil
}

// AddBosslistIDs adds the "bosslists" edge to the Bosslist entity by ids.
func (m *BossMutation) AddBosslistIDs(ids ...uuid.UUID) {
	if m.bosslists == nil {
		m.bosslists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bosslists[ids[i]] = struct{}{}
	}
}

// ClearBosslists clears the "bosslists" edge to the Bosslist entity.
func (m *BossMutation) ClearBosslists() {
	m.clearedbosslists = true
}

// BosslistsCleared reports if the "bosslists" edge to the Bosslist entity was cleared.
func (m *BossMutation) BosslistsCleared() bool {
	return m.clearedbosslists
}

// RemoveBosslistIDs removes the "bosslists" edge to the Bosslist entity by IDs.
func (m *BossMutation) RemoveBosslistIDs(ids ...uuid.UUID) {
	if m.removedbosslists == nil {
		m.removedbosslists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bosslists, ids[i])
		m.removedbosslists[ids[i]] = struct{}{}
	}
}

// RemovedBosslists returns the removed IDs of the "bosslists" edge to the Bosslist entity.
func (m *BossMutation) RemovedBosslistsIDs() (ids []uuid.UUID) {
	for id := range m.removedbosslists {
		ids = append(ids, id)
	}
	return
}

// BosslistsIDs returns the "bosslists" edge IDs in the mutation.
func (m *BossMutation) BosslistsIDs() (ids []uuid.UUID) {
	for id := range m.bosslists {
		ids = append(ids, id)
	}
	return
}

// ResetBosslists resets all changes to the "bosslists" edge.
func (m *BossMutation) ResetBosslists() {
	m.bosslists = nil
	m.clearedbosslists = false
	m.removedbosslists = nil
}

// Where appends a list predicates to the BossMutation builder.
func (m *BossMutation) Where(ps ...predicate.Boss) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BossMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Boss).
func (m *BossMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BossMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, boss.FieldName)
	}
	if m.template != nil {
		fields = append(fields, boss.FieldTemplate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BossMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case boss.FieldName:
		return m.Name()
	case boss.FieldTemplate:
		return m.Template()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BossMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case boss.FieldName:
		return m.OldName(ctx)
	case boss.FieldTemplate:
		return m.OldTemplate(ctx)
	}
	return nil, fmt.Errorf("unknown Boss field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BossMutation) SetField(name string, value ent.Value) error {
	switch name {
	case boss.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case boss.FieldTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	}
	return fmt.Errorf("unknown Boss field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BossMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BossMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BossMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Boss numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BossMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BossMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BossMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Boss nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BossMutation) ResetField(name string) error {
	switch name {
	case boss.FieldName:
		m.ResetName()
		return nil
	case boss.FieldTemplate:
		m.ResetTemplate()
		return nil
	}
	return fmt.Errorf("unknown Boss field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BossMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bosslists != nil {
		edges = append(edges, boss.EdgeBosslists)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BossMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case boss.EdgeBosslists:
		ids := make([]ent.Value, 0, len(m.bosslists))
		for id := range m.bosslists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BossMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbosslists != nil {
		edges = append(edges, boss.EdgeBosslists)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BossMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case boss.EdgeBosslists:
		ids := make([]ent.Value, 0, len(m.removedbosslists))
		for id := range m.removedbosslists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BossMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbosslists {
		edges = append(edges, boss.EdgeBosslists)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BossMutation) EdgeCleared(name string) bool {
	switch name {
	case boss.EdgeBosslists:
		return m.clearedbosslists
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BossMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Boss unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BossMutation) ResetEdge(name string) error {
	switch name {
	case boss.EdgeBosslists:
		m.ResetBosslists()
		return nil
	}
	return fmt.Errorf("unknown Boss edge %s", name)
}

// BosslistMutation represents an operation that mutates the Bosslist nodes in the graph.
type BosslistMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	starts_at           *time.Time
	custom_template     *string
	discord_message_id  *string
	clearedFields       map[string]struct{}
	boss                *uuid.UUID
	clearedboss         bool
	participants        map[uuid.UUID]struct{}
	removedparticipants map[uuid.UUID]struct{}
	clearedparticipants bool
	done                bool
	oldValue            func(context.Context) (*Bosslist, error)
	predicates          []predicate.Bosslist
}

var _ ent.Mutation = (*BosslistMutation)(nil)

// bosslistOption allows management of the mutation configuration using functional options.
type bosslistOption func(*BosslistMutation)

// newBosslistMutation creates new mutation for the Bosslist entity.
func newBosslistMutation(c config, op Op, opts ...bosslistOption) *BosslistMutation {
	m := &BosslistMutation{
		config:        c,
		op:            op,
		typ:           TypeBosslist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBosslistID sets the ID field of the mutation.
func withBosslistID(id uuid.UUID) bosslistOption {
	return func(m *BosslistMutation) {
		var (
			err   error
			once  sync.Once
			value *Bosslist
		)
		m.oldValue = func(ctx context.Context) (*Bosslist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bosslist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBosslist sets the old Bosslist of the mutation.
func withBosslist(node *Bosslist) bosslistOption {
	return func(m *BosslistMutation) {
		m.oldValue = func(context.Context) (*Bosslist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BosslistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BosslistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bosslist entities.
func (m *BosslistMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BosslistMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BosslistMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bosslist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BosslistMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BosslistMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bosslist entity.
// If the Bosslist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BosslistMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BosslistMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStartsAt sets the "starts_at" field.
func (m *BosslistMutation) SetStartsAt(t time.Time) {
	m.starts_at = &t
}

// StartsAt returns the value of the "starts_at" field in the mutation.
func (m *BosslistMutation) StartsAt() (r time.Time, exists bool) {
	v := m.starts_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAt returns the old "starts_at" field's value of the Bosslist entity.
// If the Bosslist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BosslistMutation) OldStartsAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAt: %w", err)
	}
	return oldValue.StartsAt, nil
}

// ResetStartsAt resets all changes to the "starts_at" field.
func (m *BosslistMutation) ResetStartsAt() {
	m.starts_at = nil
}

// SetCustomTemplate sets the "custom_template" field.
func (m *BosslistMutation) SetCustomTemplate(s string) {
	m.custom_template = &s
}

// CustomTemplate returns the value of the "custom_template" field in the mutation.
func (m *BosslistMutation) CustomTemplate() (r string, exists bool) {
	v := m.custom_template
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomTemplate returns the old "custom_template" field's value of the Bosslist entity.
// If the Bosslist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BosslistMutation) OldCustomTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomTemplate: %w", err)
	}
	return oldValue.CustomTemplate, nil
}

// ClearCustomTemplate clears the value of the "custom_template" field.
func (m *BosslistMutation) ClearCustomTemplate() {
	m.custom_template = nil
	m.clearedFields[bosslist.FieldCustomTemplate] = struct{}{}
}

// CustomTemplateCleared returns if the "custom_template" field was cleared in this mutation.
func (m *BosslistMutation) CustomTemplateCleared() bool {
	_, ok := m.clearedFields[bosslist.FieldCustomTemplate]
	return ok
}

// ResetCustomTemplate resets all changes to the "custom_template" field.
func (m *BosslistMutation) ResetCustomTemplate() {
	m.custom_template = nil
	delete(m.clearedFields, bosslist.FieldCustomTemplate)
}

// SetDiscordMessageID sets the "discord_message_id" field.
func (m *BosslistMutation) SetDiscordMessageID(s string) {
	m.discord_message_id = &s
}

// DiscordMessageID returns the value of the "discord_message_id" field in the mutation.
func (m *BosslistMutation) DiscordMessageID() (r string, exists bool) {
	v := m.discord_message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordMessageID returns the old "discord_message_id" field's value of the Bosslist entity.
// If the Bosslist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BosslistMutation) OldDiscordMessageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscordMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscordMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordMessageID: %w", err)
	}
	return oldValue.DiscordMessageID, nil
}

// ClearDiscordMessageID clears the value of the "discord_message_id" field.
func (m *BosslistMutation) ClearDiscordMessageID() {
	m.discord_message_id = nil
	m.clearedFields[bosslist.FieldDiscordMessageID] = struct{}{}
}

// DiscordMessageIDCleared returns if the "discord_message_id" field was cleared in this mutation.
func (m *BosslistMutation) DiscordMessageIDCleared() bool {
	_, ok := m.clearedFields[bosslist.FieldDiscordMessageID]
	return ok
}

// ResetDiscordMessageID resets all changes to the "discord_message_id" field.
func (m *BosslistMutation) ResetDiscordMessageID() {
	m.discord_message_id = nil
	delete(m.clearedFields, bosslist.FieldDiscordMessageID)
}

// SetBossID sets the "boss" edge to the Boss entity by id.
func (m *BosslistMutation) SetBossID(id uuid.UUID) {
	m.boss = &id
}

// ClearBoss clears the "boss" edge to the Boss entity.
func (m *BosslistMutation) ClearBoss() {
	m.clearedboss = true
}

// BossCleared reports if the "boss" edge to the Boss entity was cleared.
func (m *BosslistMutation) BossCleared() bool {
	return m.clearedboss
}

// BossID returns the "boss" edge ID in the mutation.
func (m *BosslistMutation) BossID() (id uuid.UUID, exists bool) {
	if m.boss != nil {
		return *m.boss, true
	}
	return
}

// BossIDs returns the "boss" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BossID instead. It exists only for internal usage by the builders.
func (m *BosslistMutation) BossIDs() (ids []uuid.UUID) {
	if id := m.boss; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBoss resets all changes to the "boss" edge.
func (m *BosslistMutation) ResetBoss() {
	m.boss = nil
	m.clearedboss = false
}

// AddParticipantIDs adds the "participants" edge to the Participant entity by ids.
func (m *BosslistMutation) AddParticipantIDs(ids ...uuid.UUID) {
	if m.participants == nil {
		m.participants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the Participant entity.
func (m *BosslistMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the Participant entity was cleared.
func (m *BosslistMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the Participant entity by IDs.
func (m *BosslistMutation) RemoveParticipantIDs(ids ...uuid.UUID) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the Participant entity.
func (m *BosslistMutation) RemovedParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *BosslistMutation) ParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *BosslistMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// Where appends a list predicates to the BosslistMutation builder.
func (m *BosslistMutation) Where(ps ...predicate.Bosslist) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BosslistMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bosslist).
func (m *BosslistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BosslistMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, bosslist.FieldCreatedAt)
	}
	if m.starts_at != nil {
		fields = append(fields, bosslist.FieldStartsAt)
	}
	if m.custom_template != nil {
		fields = append(fields, bosslist.FieldCustomTemplate)
	}
	if m.discord_message_id != nil {
		fields = append(fields, bosslist.FieldDiscordMessageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BosslistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bosslist.FieldCreatedAt:
		return m.CreatedAt()
	case bosslist.FieldStartsAt:
		return m.StartsAt()
	case bosslist.FieldCustomTemplate:
		return m.CustomTemplate()
	case bosslist.FieldDiscordMessageID:
		return m.DiscordMessageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BosslistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bosslist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bosslist.FieldStartsAt:
		return m.OldStartsAt(ctx)
	case bosslist.FieldCustomTemplate:
		return m.OldCustomTemplate(ctx)
	case bosslist.FieldDiscordMessageID:
		return m.OldDiscordMessageID(ctx)
	}
	return nil, fmt.Errorf("unknown Bosslist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BosslistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bosslist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bosslist.FieldStartsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAt(v)
		return nil
	case bosslist.FieldCustomTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomTemplate(v)
		return nil
	case bosslist.FieldDiscordMessageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown Bosslist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BosslistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BosslistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BosslistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bosslist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BosslistMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bosslist.FieldCustomTemplate) {
		fields = append(fields, bosslist.FieldCustomTemplate)
	}
	if m.FieldCleared(bosslist.FieldDiscordMessageID) {
		fields = append(fields, bosslist.FieldDiscordMessageID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BosslistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BosslistMutation) ClearField(name string) error {
	switch name {
	case bosslist.FieldCustomTemplate:
		m.ClearCustomTemplate()
		return nil
	case bosslist.FieldDiscordMessageID:
		m.ClearDiscordMessageID()
		return nil
	}
	return fmt.Errorf("unknown Bosslist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BosslistMutation) ResetField(name string) error {
	switch name {
	case bosslist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bosslist.FieldStartsAt:
		m.ResetStartsAt()
		return nil
	case bosslist.FieldCustomTemplate:
		m.ResetCustomTemplate()
		return nil
	case bosslist.FieldDiscordMessageID:
		m.ResetDiscordMessageID()
		return nil
	}
	return fmt.Errorf("unknown Bosslist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BosslistMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.boss != nil {
		edges = append(edges, bosslist.EdgeBoss)
	}
	if m.participants != nil {
		edges = append(edges, bosslist.EdgeParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BosslistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bosslist.EdgeBoss:
		if id := m.boss; id != nil {
			return []ent.Value{*id}
		}
	case bosslist.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BosslistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedparticipants != nil {
		edges = append(edges, bosslist.EdgeParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BosslistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bosslist.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BosslistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedboss {
		edges = append(edges, bosslist.EdgeBoss)
	}
	if m.clearedparticipants {
		edges = append(edges, bosslist.EdgeParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BosslistMutation) EdgeCleared(name string) bool {
	switch name {
	case bosslist.EdgeBoss:
		return m.clearedboss
	case bosslist.EdgeParticipants:
		return m.clearedparticipants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BosslistMutation) ClearEdge(name string) error {
	switch name {
	case bosslist.EdgeBoss:
		m.ClearBoss()
		return nil
	}
	return fmt.Errorf("unknown Bosslist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BosslistMutation) ResetEdge(name string) error {
	switch name {
	case bosslist.EdgeBoss:
		m.ResetBoss()
		return nil
	case bosslist.EdgeParticipants:
		m.ResetParticipants()
		return nil
	}
	return fmt.Errorf("unknown Bosslist edge %s", name)
}

// InstanceMutation represents an operation that mutates the Instance nodes in the graph.
type InstanceMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	status           *instance.Status
	discord_guild_id *string
	clearedFields    map[string]struct{}
	configs          map[uuid.UUID]struct{}
	removedconfigs   map[uuid.UUID]struct{}
	clearedconfigs   bool
	done             bool
	oldValue         func(context.Context) (*Instance, error)
	predicates       []predicate.Instance
}

var _ ent.Mutation = (*InstanceMutation)(nil)

// instanceOption allows management of the mutation configuration using functional options.
type instanceOption func(*InstanceMutation)

// newInstanceMutation creates new mutation for the Instance entity.
func newInstanceMutation(c config, op Op, opts ...instanceOption) *InstanceMutation {
	m := &InstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceID sets the ID field of the mutation.
func withInstanceID(id uuid.UUID) instanceOption {
	return func(m *InstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Instance
		)
		m.oldValue = func(ctx context.Context) (*Instance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Instance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstance sets the old Instance of the mutation.
func withInstance(node *Instance) instanceOption {
	return func(m *InstanceMutation) {
		m.oldValue = func(context.Context) (*Instance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Instance entities.
func (m *InstanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Instance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *InstanceMutation) SetStatus(i instance.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *InstanceMutation) Status() (r instance.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldStatus(ctx context.Context) (v instance.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InstanceMutation) ResetStatus() {
	m.status = nil
}

// SetDiscordGuildID sets the "discord_guild_id" field.
func (m *InstanceMutation) SetDiscordGuildID(s string) {
	m.discord_guild_id = &s
}

// DiscordGuildID returns the value of the "discord_guild_id" field in the mutation.
func (m *InstanceMutation) DiscordGuildID() (r string, exists bool) {
	v := m.discord_guild_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordGuildID returns the old "discord_guild_id" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldDiscordGuildID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscordGuildID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscordGuildID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordGuildID: %w", err)
	}
	return oldValue.DiscordGuildID, nil
}

// ResetDiscordGuildID resets all changes to the "discord_guild_id" field.
func (m *InstanceMutation) ResetDiscordGuildID() {
	m.discord_guild_id = nil
}

// AddConfigIDs adds the "configs" edge to the InstanceConfig entity by ids.
func (m *InstanceMutation) AddConfigIDs(ids ...uuid.UUID) {
	if m.configs == nil {
		m.configs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.configs[ids[i]] = struct{}{}
	}
}

// ClearConfigs clears the "configs" edge to the InstanceConfig entity.
func (m *InstanceMutation) ClearConfigs() {
	m.clearedconfigs = true
}

// ConfigsCleared reports if the "configs" edge to the InstanceConfig entity was cleared.
func (m *InstanceMutation) ConfigsCleared() bool {
	return m.clearedconfigs
}

// RemoveConfigIDs removes the "configs" edge to the InstanceConfig entity by IDs.
func (m *InstanceMutation) RemoveConfigIDs(ids ...uuid.UUID) {
	if m.removedconfigs == nil {
		m.removedconfigs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.configs, ids[i])
		m.removedconfigs[ids[i]] = struct{}{}
	}
}

// RemovedConfigs returns the removed IDs of the "configs" edge to the InstanceConfig entity.
func (m *InstanceMutation) RemovedConfigsIDs() (ids []uuid.UUID) {
	for id := range m.removedconfigs {
		ids = append(ids, id)
	}
	return
}

// ConfigsIDs returns the "configs" edge IDs in the mutation.
func (m *InstanceMutation) ConfigsIDs() (ids []uuid.UUID) {
	for id := range m.configs {
		ids = append(ids, id)
	}
	return
}

// ResetConfigs resets all changes to the "configs" edge.
func (m *InstanceMutation) ResetConfigs() {
	m.configs = nil
	m.clearedconfigs = false
	m.removedconfigs = nil
}

// Where appends a list predicates to the InstanceMutation builder.
func (m *InstanceMutation) Where(ps ...predicate.Instance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Instance).
func (m *InstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.status != nil {
		fields = append(fields, instance.FieldStatus)
	}
	if m.discord_guild_id != nil {
		fields = append(fields, instance.FieldDiscordGuildID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instance.FieldStatus:
		return m.Status()
	case instance.FieldDiscordGuildID:
		return m.DiscordGuildID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instance.FieldStatus:
		return m.OldStatus(ctx)
	case instance.FieldDiscordGuildID:
		return m.OldDiscordGuildID(ctx)
	}
	return nil, fmt.Errorf("unknown Instance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instance.FieldStatus:
		v, ok := value.(instance.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case instance.FieldDiscordGuildID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordGuildID(v)
		return nil
	}
	return fmt.Errorf("unknown Instance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Instance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Instance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceMutation) ResetField(name string) error {
	switch name {
	case instance.FieldStatus:
		m.ResetStatus()
		return nil
	case instance.FieldDiscordGuildID:
		m.ResetDiscordGuildID()
		return nil
	}
	return fmt.Errorf("unknown Instance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.configs != nil {
		edges = append(edges, instance.EdgeConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instance.EdgeConfigs:
		ids := make([]ent.Value, 0, len(m.configs))
		for id := range m.configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedconfigs != nil {
		edges = append(edges, instance.EdgeConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instance.EdgeConfigs:
		ids := make([]ent.Value, 0, len(m.removedconfigs))
		for id := range m.removedconfigs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconfigs {
		edges = append(edges, instance.EdgeConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case instance.EdgeConfigs:
		return m.clearedconfigs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Instance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceMutation) ResetEdge(name string) error {
	switch name {
	case instance.EdgeConfigs:
		m.ResetConfigs()
		return nil
	}
	return fmt.Errorf("unknown Instance edge %s", name)
}

// InstanceConfigMutation represents an operation that mutates the InstanceConfig nodes in the graph.
type InstanceConfigMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	key             *string
	value           *string
	clearedFields   map[string]struct{}
	instance        *uuid.UUID
	clearedinstance bool
	done            bool
	oldValue        func(context.Context) (*InstanceConfig, error)
	predicates      []predicate.InstanceConfig
}

var _ ent.Mutation = (*InstanceConfigMutation)(nil)

// instanceconfigOption allows management of the mutation configuration using functional options.
type instanceconfigOption func(*InstanceConfigMutation)

// newInstanceConfigMutation creates new mutation for the InstanceConfig entity.
func newInstanceConfigMutation(c config, op Op, opts ...instanceconfigOption) *InstanceConfigMutation {
	m := &InstanceConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeInstanceConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceConfigID sets the ID field of the mutation.
func withInstanceConfigID(id uuid.UUID) instanceconfigOption {
	return func(m *InstanceConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *InstanceConfig
		)
		m.oldValue = func(ctx context.Context) (*InstanceConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstanceConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstanceConfig sets the old InstanceConfig of the mutation.
func withInstanceConfig(node *InstanceConfig) instanceconfigOption {
	return func(m *InstanceConfigMutation) {
		m.oldValue = func(context.Context) (*InstanceConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InstanceConfig entities.
func (m *InstanceConfigMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceConfigMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceConfigMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InstanceConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *InstanceConfigMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *InstanceConfigMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the InstanceConfig entity.
// If the InstanceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceConfigMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *InstanceConfigMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *InstanceConfigMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *InstanceConfigMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the InstanceConfig entity.
// If the InstanceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceConfigMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *InstanceConfigMutation) ResetValue() {
	m.value = nil
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *InstanceConfigMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *InstanceConfigMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *InstanceConfigMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *InstanceConfigMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *InstanceConfigMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *InstanceConfigMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// Where appends a list predicates to the InstanceConfigMutation builder.
func (m *InstanceConfigMutation) Where(ps ...predicate.InstanceConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InstanceConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InstanceConfig).
func (m *InstanceConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceConfigMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.key != nil {
		fields = append(fields, instanceconfig.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, instanceconfig.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instanceconfig.FieldKey:
		return m.Key()
	case instanceconfig.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instanceconfig.FieldKey:
		return m.OldKey(ctx)
	case instanceconfig.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown InstanceConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instanceconfig.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case instanceconfig.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InstanceConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InstanceConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceConfigMutation) ResetField(name string) error {
	switch name {
	case instanceconfig.FieldKey:
		m.ResetKey()
		return nil
	case instanceconfig.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown InstanceConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.instance != nil {
		edges = append(edges, instanceconfig.EdgeInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instanceconfig.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinstance {
		edges = append(edges, instanceconfig.EdgeInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case instanceconfig.EdgeInstance:
		return m.clearedinstance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceConfigMutation) ClearEdge(name string) error {
	switch name {
	case instanceconfig.EdgeInstance:
		m.ClearInstance()
		return nil
	}
	return fmt.Errorf("unknown InstanceConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceConfigMutation) ResetEdge(name string) error {
	switch name {
	case instanceconfig.EdgeInstance:
		m.ResetInstance()
		return nil
	}
	return fmt.Errorf("unknown InstanceConfig edge %s", name)
}

// ParticipantMutation represents an operation that mutates the Participant nodes in the graph.
type ParticipantMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	vocation        *participant.Vocation
	discord_id      *string
	clearedFields   map[string]struct{}
	bosslist        *uuid.UUID
	clearedbosslist bool
	done            bool
	oldValue        func(context.Context) (*Participant, error)
	predicates      []predicate.Participant
}

var _ ent.Mutation = (*ParticipantMutation)(nil)

// participantOption allows management of the mutation configuration using functional options.
type participantOption func(*ParticipantMutation)

// newParticipantMutation creates new mutation for the Participant entity.
func newParticipantMutation(c config, op Op, opts ...participantOption) *ParticipantMutation {
	m := &ParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParticipantID sets the ID field of the mutation.
func withParticipantID(id uuid.UUID) participantOption {
	return func(m *ParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *Participant
		)
		m.oldValue = func(ctx context.Context) (*Participant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Participant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParticipant sets the old Participant of the mutation.
func withParticipant(node *Participant) participantOption {
	return func(m *ParticipantMutation) {
		m.oldValue = func(context.Context) (*Participant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Participant entities.
func (m *ParticipantMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParticipantMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParticipantMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Participant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVocation sets the "vocation" field.
func (m *ParticipantMutation) SetVocation(pa participant.Vocation) {
	m.vocation = &pa
}

// Vocation returns the value of the "vocation" field in the mutation.
func (m *ParticipantMutation) Vocation() (r participant.Vocation, exists bool) {
	v := m.vocation
	if v == nil {
		return
	}
	return *v, true
}

// OldVocation returns the old "vocation" field's value of the Participant entity.
// If the Participant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantMutation) OldVocation(ctx context.Context) (v participant.Vocation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVocation: %w", err)
	}
	return oldValue.Vocation, nil
}

// ResetVocation resets all changes to the "vocation" field.
func (m *ParticipantMutation) ResetVocation() {
	m.vocation = nil
}

// SetDiscordID sets the "discord_id" field.
func (m *ParticipantMutation) SetDiscordID(s string) {
	m.discord_id = &s
}

// DiscordID returns the value of the "discord_id" field in the mutation.
func (m *ParticipantMutation) DiscordID() (r string, exists bool) {
	v := m.discord_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordID returns the old "discord_id" field's value of the Participant entity.
// If the Participant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantMutation) OldDiscordID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscordID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscordID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordID: %w", err)
	}
	return oldValue.DiscordID, nil
}

// ResetDiscordID resets all changes to the "discord_id" field.
func (m *ParticipantMutation) ResetDiscordID() {
	m.discord_id = nil
}

// SetBosslistID sets the "bosslist" edge to the Bosslist entity by id.
func (m *ParticipantMutation) SetBosslistID(id uuid.UUID) {
	m.bosslist = &id
}

// ClearBosslist clears the "bosslist" edge to the Bosslist entity.
func (m *ParticipantMutation) ClearBosslist() {
	m.clearedbosslist = true
}

// BosslistCleared reports if the "bosslist" edge to the Bosslist entity was cleared.
func (m *ParticipantMutation) BosslistCleared() bool {
	return m.clearedbosslist
}

// BosslistID returns the "bosslist" edge ID in the mutation.
func (m *ParticipantMutation) BosslistID() (id uuid.UUID, exists bool) {
	if m.bosslist != nil {
		return *m.bosslist, true
	}
	return
}

// BosslistIDs returns the "bosslist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BosslistID instead. It exists only for internal usage by the builders.
func (m *ParticipantMutation) BosslistIDs() (ids []uuid.UUID) {
	if id := m.bosslist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBosslist resets all changes to the "bosslist" edge.
func (m *ParticipantMutation) ResetBosslist() {
	m.bosslist = nil
	m.clearedbosslist = false
}

// Where appends a list predicates to the ParticipantMutation builder.
func (m *ParticipantMutation) Where(ps ...predicate.Participant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ParticipantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Participant).
func (m *ParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParticipantMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.vocation != nil {
		fields = append(fields, participant.FieldVocation)
	}
	if m.discord_id != nil {
		fields = append(fields, participant.FieldDiscordID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case participant.FieldVocation:
		return m.Vocation()
	case participant.FieldDiscordID:
		return m.DiscordID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case participant.FieldVocation:
		return m.OldVocation(ctx)
	case participant.FieldDiscordID:
		return m.OldDiscordID(ctx)
	}
	return nil, fmt.Errorf("unknown Participant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case participant.FieldVocation:
		v, ok := value.(participant.Vocation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVocation(v)
		return nil
	case participant.FieldDiscordID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordID(v)
		return nil
	}
	return fmt.Errorf("unknown Participant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParticipantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParticipantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Participant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParticipantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParticipantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Participant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParticipantMutation) ResetField(name string) error {
	switch name {
	case participant.FieldVocation:
		m.ResetVocation()
		return nil
	case participant.FieldDiscordID:
		m.ResetDiscordID()
		return nil
	}
	return fmt.Errorf("unknown Participant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bosslist != nil {
		edges = append(edges, participant.EdgeBosslist)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case participant.EdgeBosslist:
		if id := m.bosslist; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParticipantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbosslist {
		edges = append(edges, participant.EdgeBosslist)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case participant.EdgeBosslist:
		return m.clearedbosslist
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParticipantMutation) ClearEdge(name string) error {
	switch name {
	case participant.EdgeBosslist:
		m.ClearBosslist()
		return nil
	}
	return fmt.Errorf("unknown Participant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParticipantMutation) ResetEdge(name string) error {
	switch name {
	case participant.EdgeBosslist:
		m.ResetBosslist()
		return nil
	}
	return fmt.Errorf("unknown Participant edge %s", name)
}
